                                ; ascii art font generator : http://patorjk.com/software/taag/#p=display&f=Small
                                .include "version.asm"
                                .enum $0000
00000                           
00000                           STR_BUILD EQU "261"
00000                           BUILD = 261
00000                           
00000                           STR_VERSION EQU "0.0.1"
00000                           ;VERSION = 0.0.1
00000                           
00000                           .ende                                
                                ; ################################################################################
                                ; HEADER
                                
                                .enum $0000
00000                           
00000                           NES_MAPPER    EQU 3872
00000                           NES_PRG_BANKS EQU 32
00000                           NES_CHR_BANKS EQU 0
00000                           NES_MIRRORING EQU 0
00000                           
00000                           .ende
                                
                                ; NES 2.0 format
      4E 45 53 1A               .db "NES", $1A      ; flags 0-3: ines magic
      20                        .db <32  ; flag 4
      00                        .db <0  ; flag 5
      00                        .db <(0|(3872&$0F)<<4) ; flag 6
      28                        .db <((3872&$F0)|%00001000) ; flag 7: upper nybble of mapper number + iNES 2.0
      0F                        .db <((3872&$F00)>>8) ; flag 8
      00                        .db 0 ; flag 9
      00                        .db 0 ; flag 10: PRG-RAM shift counter - (64 << shift counter)
      09                        .db 9 ; flag 11: CHR-RAM shift counter - (64 << shift counter)
      00                        .db $00   ; flag 12
      00                        .db $00   ; flag 13
      00                        .db $00   ; flag 14
      00                        .db $00   ; flag 15
                                
                                ; ################################################################################
                                ; ZEROPAGE
                                
                                  .enum $0000
00000                           
00000                               zp0   .dsb 1
00001                               zp1   .dsb 1
00002                               zp2   .dsb 1
00003                               zp3   .dsb 1
00004                               zp4   .dsb 1
00005                               zp5   .dsb 1
00006                               zp6   .dsb 1
00007                               zp7   .dsb 1
00008                               zp8   .dsb 1
00009                               zp9   .dsb 1
0000A                               zp10  .dsb 1
0000B                               zp11  .dsb 1
0000C                               zp12  .dsb 1
0000D                               zp13  .dsb 1
0000E                               zp14  .dsb 1
0000F                               zp15  .dsb 1
00010                           
00010                               zp16  .dsb 1
00011                               zp17  .dsb 1
00012                               zp18  .dsb 1
00013                               zp19  .dsb 1
00014                               zp20  .dsb 1
00015                               zp21  .dsb 1
00016                               zp22  .dsb 1
00017                               zp23  .dsb 1
00018                               zp24  .dsb 1
00019                               zp25  .dsb 1
0001A                               zp26  .dsb 1
0001B                               zp27  .dsb 1
0001C                               zp28  .dsb 1
0001D                               zp29  .dsb 1
0001E                               zp30  .dsb 1
0001F                               zp31  .dsb 1
00020                           
00020                           	.ende
                                
                                ; ################################################################################
                                ; PADDING
                                
                                  .rept 31
                                	.base $8000
                                	.org $c000
      00 00 00 00 00 00 00 00..   .endr
0C000                           
0C000                             .base $c000
0C000 00 00 00 00 00 00 00 00.. 	.org $e000
0E000                           
0E000                           ; ################################################################################
0E000                           ; INCLUDES
0E000                           
0E000                           .include "mapper-registers.asm"
0E000                           ; ################################################################################
0E000                           ; MAPPER REGISTERS
0E000                           
0E000                           ; ESP / WiFi
0E000                           MAP_RNBW_CONFIG     = $4100
0E000                           MAP_RNBW_RX         = $4101
0E000                           MAP_RNBW_TX         = $4102
0E000                           MAP_RNBW_RX_HI_ADD  = $4103
0E000                           MAP_RNBW_RX_LO_ADD  = $4104
0E000                           MAP_RNBW_TX_HI_ADD  = $4105
0E000                           MAP_RNBW_TX_LO_ADD  = $4106
0E000                           
0E000                           ; Mapper configuration
0E000                           MAP_CONFIG      = $4110
0E000                           MAP_VERSION     = $4113
0E000                           
0E000                           ; PRG banking
0E000                           MAP_PRG_8       = $4120
0E000                           MAP_PRG_A       = $4121
0E000                           MAP_PRG_C       = $4122
0E000                           MAP_PRG_5       = $4123
0E000                           MAP_PRG_6       = $4124
0E000                           
0E000                           ; CHR banking
0E000                           MAP_CHR_0       = $4130
0E000                           MAP_CHR_1       = $4131
0E000                           MAP_CHR_2       = $4132
0E000                           MAP_CHR_3       = $4133
0E000                           MAP_CHR_4       = $4134
0E000                           MAP_CHR_5       = $4135
0E000                           MAP_CHR_6       = $4136
0E000                           MAP_CHR_7       = $4137
0E000                           
0E000                           MAP_CHR_UPPER_BIT = $4138
0E000                           
0E000                           ; IRQ
0E000                           MAP_IRQ_LATCH   = $4140
0E000                           MAP_IRQ_RELOAD  = $4141
0E000                           MAP_IRQ_DISABLE = $4142
0E000                           MAP_IRQ_ENABLE  = $4143
0E000                           
0E000                           ; Audio expansion
0E000                           MAP_SND_P1_CTRL   = $4150
0E000                           MAP_SND_P1_LOW    = $4151
0E000                           MAP_SND_P1_HIGH   = $4152
0E000                           MAP_SND_P2_CTRL   = $4153
0E000                           MAP_SND_P2_LOW    = $4154
0E000                           MAP_SND_P2_HIGH   = $4155
0E000                           MAP_SND_SAW_ACC   = $4156
0E000                           MAP_SND_SAW_LOW   = $4157
0E000                           MAP_SND_SAW_HIGH  = $4158
0E000                           
0E000                           ; Multiplier
0E000                           
0E000                           MAP_MUL_A = $4160
0E000                           MAP_MUL_B = $4161
0E000                           
0E000                           ; ################################################################################
0E000                           ; MAPPER FLAGS / MASKS
0E000                           
0E000                           CHIP_MANUF_ID         = $BF
0E000                           CHIP_SIZE_128K        = $B5
0E000                           CHIP_SIZE_256K        = $B6
0E000                           CHIP_SIZE_512K        = $B7
0E000                           
0E000                           PRG_MODE_16K_8K_8K    = %00000000 ; 16K + 8K + 8K fixed
0E000                           PRG_MODE_8K_8K_8K_8K  = %00000001 ; 8K + 8K + 8K fixed
0E000                           PRG_MODE_CLEAR        = %00000001^$ff
0E000                           
0E000                           CHR_MODE_1K           = %00000000 ; 1K mode
0E000                           CHR_MODE_2K           = %00000010 ; 2K mode
0E000                           CHR_MODE_4K           = %00000100 ; 4K mode
0E000                           CHR_MODE_8K           = %00000110 ; 8K mode
0E000                           CHR_MODE_MASK         = %00000110
0E000                           CHR_MODE_CLEAR        = CHR_MODE_MASK^$ff
0E000                           
0E000                           CHR_CHIP_ROM          = %00000000 ; CHR-ROM
0E000                           CHR_CHIP_RAM          = %00001000 ; CHR-RAM
0E000                           CHR_CHIP_MASK         = %00001000
0E000                           CHR_CHIP_CLEAR        = CHR_CHIP_MASK^$ff
0E000                           
0E000                           MIRRORING_VERTICAL    = %00000000 ; VRAM
0E000                           MIRRORING_HORIZONTAL  = %00010000 ; VRAM
0E000                           MIRRORING_ONE_SCREEN  = %00100000 ; VRAM
0E000                           MIRRORING_FOUR_SCREEN = %00110000 ; VRAM + CHR-RAM
0E000                           
0E000                           MIRRORING_MASK        = %00110000
0E000                           MIRRORING_CLEAR       = MIRRORING_MASK^$ff
0E000                           
0E000                           CHR_SCREEN_SELECT_MASK  = %11000000
0E000                           CHR_SCREEN_SELECT_CLEAR = CHR_SCREEN_SELECT_MASK^$ff
0E000                           
0E000                           CHR_1_SCREEN_1  = %00000000
0E000                           CHR_1_SCREEN_2  = %01000000
0E000                           CHR_1_SCREEN_3  = %10000000
0E000                           CHR_1_SCREEN_4  = %11000000
0E000                           
0E000                           CHR_4_SCREEN_1  = %00000000
0E000                           CHR_4_SCREEN_2  = %01000000
0E000                           CHR_4_SCREEN_3  = %10000000
0E000                           CHR_4_SCREEN_4  = %11000000
0E000                           
0E000                           ; NES LIB
0E000                           ; based on Shiru's code: https://shiru.untergrund.net/code.shtml
0E000                           .org $E000
0E000                           .include "nes-lib/nes-lib.asm"
0E000                           ; ####################################################################################################
0E000                           ; ZEROPAGE
0E000                           
0E000                           ; PPU
0E000                           
0E000                           .enum $0020
00020                           
00020                           FRAME_CNT1          .dsb 1
00021                           FRAME_CNT2          .dsb 1
00022                           
00022                           PPU_CTRL_VAR        .dsb 1
00023                           PPU_MASK_VAR        .dsb 1
00024                           
00024                           tvSystem            .dsb 1
00025                           
00025                           palUpdate           .dsb 1
00026                           PAL_BG_PTR          .dsb 2
00028                           PAL_SPR_PTR         .dsb 2
0002A                           
0002A                           palBrightness       .dsb 1
0002B                           palFadeTo           .dsb 1
0002C                           palFadeDelay        .dsb 1
0002D                           palFadeCounter      .dsb 1
0002E                           
0002E                           PTR                 .dsb 2
00030                           LEN                 .dsb 1
00031                           VRAM_UPDATE         .dsb 1
00032                           NAME_UPD_ENABLE     .dsb 1
00033                           NAME_UPD_ADR        .dsb 2
00035                           ; NAME_UPD_PTR        .dsb 2 ; not used for now
00035                           
00035                           TEMP                EQU $00
00035                           
00035                           ; SYSTEM
00035                           
00035                           ; prng var
00035                           seed               .dsb 2  ; initialize 16-bit seed to any value except 0
00037                           
00037                           ; mult8x8 / mult16x8 / mult16x16
00037                           
00037                           multNum1    EQU $00   ; word
00037                           multNum2    EQU $01   ; byte / word
00037                           product     EQU $03   ; double
00037                           
00037                           ; div16_16
00037                           
00037                           divisor     EQU $00   ; word
00037                           dividend    EQU $01   ; word
00037                           remainder   EQU $03   ; word
00037                           result      EQU $01  ; save memory by reusing dividend to store the result
00037                           
00037                           ; Binary2Decimal vars
00037                           
00037                           tempBinary         .dsb 2
00039                           decimalResult      .dsb 5
0003E                           
0003E                           ; PAD
0003E                           
0003E                           padStateOld        .dsb 1
0003F                           padState           .dsb 1
00040                           padPressed         .dsb 1
00041                           padReleased        .dsb 1
00042                           
00042                           .ende
0E000                           
0E000                           .include "nes-lib/constants.asm"
0E000                           ; ####################################################################################################
0E000                           ; NES LIB CONSTANTS
0E000                           
0E000                             PPU_CTRL        EQU $2000
0E000                             PPU_MASK        EQU $2001
0E000                             PPU_STATUS      EQU $2002
0E000                             PPU_OAM_ADDR    EQU $2003
0E000                             PPU_OAM_DATA    EQU $2004
0E000                             PPU_SCROLL      EQU $2005
0E000                             PPU_ADDR        EQU $2006
0E000                             PPU_DATA        EQU $2007
0E000                             PPU_OAM_DMA     EQU $4014
0E000                             PPU_FRAMECNT    EQU $4017
0E000                             DMC_FREQ        EQU $4010
0E000                             CTRL_PORT1      EQU $4016
0E000                             CTRL_PORT2      EQU $4017
0E000                           
0E000                             OAM_BUF         EQU $0200
0E000                             PALETTE         EQU $0160 ;$01A0
0E000                             PAL_BUF         EQU $0180 ;$01C0
0E000                           
0E000                             ; #####
0E000                           
0E000                             PAD_A           EQU $01
0E000                             PAD_B           EQU $02
0E000                             PAD_SELECT      EQU $04
0E000                             PAD_START       EQU $08
0E000                             PAD_UP          EQU $10
0E000                             PAD_DOWN        EQU $20
0E000                             PAD_LEFT        EQU $40
0E000                             PAD_RIGHT       EQU $80
0E000                           
0E000                             OAM_FLIP_V      EQU $80
0E000                             OAM_FLIP_H      EQU $40
0E000                             OAM_BEHIND      EQU $20
0E000                           
0E000                             MASK_SPR        EQU $10
0E000                             MASK_BG         EQU $08
0E000                             MASK_EDGE_SPR   EQU $04
0E000                             MASK_EDGE_BG    EQU $02
0E000                           
0E000                             NAMETABLE_A     EQU $2000
0E000                             NAMETABLE_B     EQU $2400
0E000                             NAMETABLE_C     EQU $2800
0E000                             NAMETABLE_D     EQU $2C00
0E000                           
0E000                             ATTRIBUTE_A     EQU $23C0
0E000                             ATTRIBUTE_B     EQU $27C0
0E000                             ATTRIBUTE_C     EQU $2BC0
0E000                             ATTRIBUTE_D     EQU $2FC0
0E000                           
0E000                             NULL            EQU 0
0E000                             TRUE            EQU 1
0E000                             FALSE           EQU 0
0E000                           
0E000                             NT_UPD_HORZ     EQU $40
0E000                             NT_UPD_VERT     EQU $80
0E000                             NT_UPD_EOF      EQU $FF
0E000                           .include "nes-lib/ppu.asm"
0E000                           ; ################################################################################
0E000                           ; PPU LIBRARY
0E000                           
0E000                           	; ################################################################################
0E000                           	; CODE
0E000                           
0E000                           	;
0E000                           	; NES TV system detection code
0E000                           	; Copyright 2011 Damian Yerrick
0E000                           	;
0E000                           	; Copying and distribution of this file, with or without
0E000                           	; modification, are permitted in any medium without royalty provided
0E000                           	; the copyright notice and this notice are preserved in all source
0E000                           	; code copies.  This file is offered as-is, without any warranty.
0E000                           	;
0E000                           	;.segment "CODE"
0E000                           	.align 32
0E000                           	;;
0E000                           	; Detects which of NTSC, PAL, or Dendy is in use by counting cycles
0E000                           	; between NMIs.
0E000                           	;
0E000                           	; NTSC NES produces 262 scanlines, with 341/3 CPU cycles per line.
0E000                           	; PAL NES produces 312 scanlines, with 341/3.2 CPU cycles per line.
0E000                           	; Its vblank is longer than NTSC, and its CPU is slower.
0E000                           	; Dendy is a Russian famiclone distributed by Steepler that uses the
0E000                           	; PAL signal with a CPU as fast as the NTSC CPU.  Its vblank is as
0E000                           	; long as PAL's, but its NMI occurs toward the end of vblank (line
0E000                           	; 291 instead of 241) so that cycle offsets from NMI remain the same
0E000                           	; as NTSC, keeping Balloon Fight and any game using a CPU cycle-
0E000                           	; counting mapper (e.g. FDS, Konami VRC) working.
0E000                           	;
0E000                           	; nmis is a variable that the NMI handler modifies every frame.
0E000                           	; Make sure your NMI handler finishes within 1500 or so cycles (not
0E000                           	; taking the whole NMI or waiting for sprite 0) while calling this,
0E000                           	; or the result in A will be wrong.
0E000                           	;
0E000                           	; @return A: TV system (0: NTSC, 1: PAL, 2: Dendy; 3: unknown
0E000                           	;         Y: high byte of iterations used (1 iteration = 11 cycles)
0E000                           	;         X: low byte of iterations used
0E000                           	getTVSystem:
0E000                           
0E000                           		nmis = FRAME_CNT1
0E000                           
0E000 A2 00                     		ldx #0
0E002 A0 00                     		ldy #0
0E004 A5 20                     		lda nmis
0E006                           	nmiwait1:
0E006 C5 20                     		cmp nmis
0E008 F0 FC                     		beq nmiwait1
0E00A A5 20                     		lda nmis
0E00C                           
0E00C                           	nmiwait2:
0E00C                           		; Each iteration takes 11 cycles.
0E00C                           		; NTSC NES: 29780 cycles or 2707 = $A93 iterations
0E00C                           		; PAL NES:  33247 cycles or 3022 = $BCE iterations
0E00C                           		; Dendy:    35464 cycles or 3224 = $C98 iterations
0E00C                           		; so we can divide by $100 (rounding down), subtract ten,
0E00C                           		; and end up with 0=ntsc, 1=pal, 2=dendy, 3=unknown
0E00C E8                        		inx
0E00D D0 01                     		bne +
0E00F C8                        		iny
0E010                           	+
0E010 C5 20                     		cmp nmis
0E012 F0 F8                     		beq nmiwait2
0E014 98                        		tya
0E015 38                        		sec
0E016 E9 0A                     		sbc #10
0E018 C9 03                     		cmp #3
0E01A 90 02                     		bcc notAbove3
0E01C A9 03                     		lda #3
0E01E                           	notAbove3:
0E01E 85 24                     		sta tvSystem
0E020 60                        		rts
0E021                           	
0E021                           
0E021                           
0E021                           	ppu_off_all:
0E021                           
0E021 A5 23                     		lda PPU_MASK_VAR
0E023 29 E7                     		and #%11100111
0E025 4C 3A E0                  		jmp ppu_onoff
0E028                           
0E028                           	
0E028                           
0E028                           	ppu_off_bg:
0E028                           
0E028 A5 23                     		lda PPU_MASK_VAR
0E02A 29 F7                     		and #%11110111
0E02C 4C 3A E0                  		jmp ppu_onoff
0E02F                           
0E02F                           	
0E02F                           
0E02F                           	ppu_off_spr:
0E02F                           
0E02F A5 23                     		lda PPU_MASK_VAR
0E031 29 EF                     		and #%11101111
0E033 4C 3A E0                  		jmp ppu_onoff
0E036                           
0E036                           	
0E036                           
0E036                           	ppu_on_all:
0E036                           
0E036 A5 23                     		lda PPU_MASK_VAR
0E038 09 18                     		ora #%00011000
0E03A                           	;    JMP ppu_onoff ; ???????
0E03A                           
0E03A                           	
0E03A                           
0E03A                           	ppu_onoff:
0E03A                           
0E03A 85 23                     		sta PPU_MASK_VAR
0E03C 4C 9D E0                  		jmp waitNMI
0E03F                           	;    STA PPU_MASK
0E03F                           		;RTS
0E03F                           
0E03F                           	
0E03F                           
0E03F                           	oam_clear:
0E03F A2 00                     		ldx #0
0E041 A9 FF                     		lda #$FF
0E043                           	loop:
0E043 9D 00 02                  		sta $0200,x
0E046 E8                        		inx
0E047 E8                        		inx
0E048 E8                        		inx
0E049 E8                        		inx
0E04A D0 F7                     		bne loop
0E04C 60                        		rts
0E04D                           	
0E04D                           
0E04D                           	oam_meta_spr:
0E04D                           		; PTR: pointer to sprite data
0E04D                           		; X: x position
0E04D                           		; Y: y position
0E04D                           		; A: sprite id (0-64)
0E04D                           
0E04D                           		SCRX    = $00
0E04D                           		SCRY    = $01
0E04D                           
0E04D 86 00                     		stx SCRX
0E04F 84 01                     		sty SCRY
0E051 AA                        		tax
0E052 A0 00                     		ldy #0
0E054                           
0E054                           	@1:
0E054 B1 2E                     		lda (PTR),y     ; x offset
0E056 C9 80                     		cmp #$80
0E058 F0 23                     		beq @2
0E05A C8                        		iny
0E05B 18                        		clc
0E05C 65 00                     		adc <SCRX
0E05E 9D 03 02                  		sta $0200+3,x
0E061 B1 2E                     		lda (PTR),y     ; y offset
0E063 C8                        		iny
0E064 18                        		clc
0E065 65 01                     		adc <SCRY
0E067 9D 00 02                  		sta $0200+0,x
0E06A B1 2E                     		lda (PTR),y     ; tile
0E06C C8                        		iny
0E06D 9D 01 02                  		sta $0200+1,x
0E070 B1 2E                     		lda (PTR),y     ; attribute
0E072 C8                        		iny
0E073 9D 02 02                  		sta $0200+2,x
0E076 E8                        		inx
0E077 E8                        		inx
0E078 E8                        		inx
0E079 E8                        		inx
0E07A 4C 54 E0                  		jmp @1
0E07D                           
0E07D                           	@2:
0E07D                           
0E07D 8A                        		txa
0E07E                           
0E07E                           		; return
0E07E 60                        		rts
0E07F                           	
0E07F                           
0E07F                           	oam_hide_rest:
0E07F AA                        		tax
0E080 A9 F0                     		lda #240
0E082                           	-
0E082 9D 00 02                  		sta $0200,x
0E085 E8                        		inx
0E086 E8                        		inx
0E087 E8                        		inx
0E088 E8                        		inx
0E089 D0 F7                     		bne -
0E08B                           
0E08B                           		; return
0E08B 60                        		rts
0E08C                           	
0E08C                           
0E08C                           	waitFrame:
0E08C                           
0E08C                           		;lda #1
0E08C                           		;sta VRAM_UPDATE
0E08C A5 20                     		lda FRAME_CNT1
0E08E                           	-
0E08E C5 20                     		cmp FRAME_CNT1
0E090 F0 FC                     		beq -
0E092 A5 24                     		lda tvSystem
0E094 F0 06                     		beq +
0E096                           	-
0E096 A5 21                     		lda FRAME_CNT2
0E098 C9 05                     		cmp #5
0E09A F0 FA                     		beq -
0E09C                           	+
0E09C                           
0E09C 60                        		rts
0E09D                           
0E09D                           	
0E09D                           
0E09D                           	waitNMI:
0E09D                           
0E09D                           		;lda #1
0E09D                           		;sta VRAM_UPDATE
0E09D A5 20                     		lda FRAME_CNT1
0E09F                           	-
0E09F C5 20                     		cmp FRAME_CNT1
0E0A1 F0 FC                     		beq -
0E0A3 60                        		rts
0E0A4                           
0E0A4                           	
0E0A4                           
0E0A4                           	setPaletteBrightness:
0E0A4                           
0E0A4 85 2A                     		sta palBrightness
0E0A6 20 BF E0                  		jsr pal_spr_bright
0E0A9 8A                        		txa
0E0AA 4C AD E0                  		jmp pal_bg_bright
0E0AD                           
0E0AD                           	
0E0AD                           
0E0AD                           	pal_bg_bright:
0E0AD                           
0E0AD AA                        		tax
0E0AE BD CA E3                  		lda palBrightTableL,x
0E0B1 85 26                     		sta <PAL_BG_PTR
0E0B3 BD D3 E3                  		lda palBrightTableH,x    ;MSB is never zero
0E0B6 85 27                     		sta <PAL_BG_PTR+1
0E0B8 A9 01                     		lda #$01
0E0BA 85 25                     		sta <palUpdate
0E0BC                           
0E0BC 4C D1 E0                  		jmp pal_bg_to_buf
0E0BF                           
0E0BF                           	
0E0BF                           
0E0BF                           	pal_spr_bright:
0E0BF                           
0E0BF AA                        		tax
0E0C0 BD CA E3                  		lda palBrightTableL,x
0E0C3 85 28                     		sta <PAL_SPR_PTR
0E0C5 BD D3 E3                  		lda palBrightTableH,x    ;MSB is never zero
0E0C8 85 29                     		sta <PAL_SPR_PTR+1
0E0CA A9 01                     		lda #$01
0E0CC 85 25                     		sta <palUpdate
0E0CE                           
0E0CE 4C 52 E1                  		jmp pal_spr_to_buf
0E0D1                           
0E0D1                           	
0E0D1                           
0E0D1                           	pal_bg_to_buf:
0E0D1                           
0E0D1                           		J=0
0E0D1                           		I=0
0E0D1                           		.rept 4
0E0D1                           		.rept 4
0E0D1                           		ldy $0160+(J*4)+I
0E0D1                           		lda (PAL_BG_PTR),Y
0E0D1                           		sta $0180+(J*4)+I
0E0D1                           		I=I+1
0E0D1                           		.endr
0E0D1                           		I=0
0E0D1                           		J=J+1
0E0D1 AC 60 01 B1 26 8D 80 01.. 		.endr
0E151                           
0E151 60                        		rts
0E152                           
0E152                           	
0E152                           
0E152                           	pal_spr_to_buf:
0E152                           
0E152                           		J=0
0E152                           		I=0
0E152                           		.rept 4
0E152                           		.rept 4
0E152                           		ldy $0160+16+(J*4)+I
0E152                           		lda (PAL_SPR_PTR),Y
0E152                           		sta $0180+16+(J*4)+I
0E152                           		I=I+1
0E152                           		.endr
0E152                           		I=0
0E152                           		J=J+1
0E152 AC 70 01 B1 28 8D 90 01.. 		.endr
0E1D2                           
0E1D2 60                        		rts
0E1D3                           
0E1D3                           	
0E1D3                           
0E1D3                           	setSPR_bank:
0E1D3                           
0E1D3 29 01                     		and #$01
0E1D5 0A                        		asl A
0E1D6 0A                        		asl A
0E1D7 0A                        		asl A
0E1D8 85 00                     		sta $00
0E1DA A5 22                     		lda PPU_CTRL_VAR
0E1DC 29 F7                     		and #%11110111
0E1DE 05 00                     		ora $00
0E1E0 85 22                     		sta PPU_CTRL_VAR
0E1E2                           
0E1E2 60                        		rts
0E1E3                           
0E1E3                           	
0E1E3                           
0E1E3                           	setBG_bank:
0E1E3                           
0E1E3 29 01                     		and #$01
0E1E5 0A                        		asl A
0E1E6 0A                        		asl A
0E1E7 0A                        		asl A
0E1E8 0A                        		asl A
0E1E9 85 00                     		sta $00
0E1EB A5 22                     		lda PPU_CTRL_VAR
0E1ED 29 EF                     		and #%11101111
0E1EF 05 00                     		ora $00
0E1F1 85 22                     		sta PPU_CTRL_VAR
0E1F3                           
0E1F3 60                        		rts
0E1F4                           
0E1F4                           	
0E1F4                           
0E1F4                           	pal_bg:
0E1F4                           
0E1F4 85 2E                     		sta <PTR
0E1F6 86 2F                     		stx <PTR+1
0E1F8 A2 00                     		ldx #$00
0E1FA A9 10                     		lda #$10
0E1FC 4C 10 E2                  		jmp pal_copy
0E1FF                           
0E1FF                           	
0E1FF                           
0E1FF                           	pal_spr:
0E1FF                           
0E1FF 85 2E                     		sta <PTR
0E201 86 2F                     		stx <PTR+1
0E203 A2 10                     		ldx #$10
0E205 8A                        		txa
0E206 D0 08                     		bne pal_copy ;bra
0E208                           
0E208                           	
0E208                           
0E208                           	;pal_col:
0E208                           	;
0E208                           	;;    STA <PTR
0E208                           	;;    JSR popa
0E208                           	;;    AND #$1f
0E208                           	;;    TAX
0E208                           	;;    LDA <PTR
0E208                           	;;    STA PAL_BUF,x
0E208                           	;;    INC <palUpdate
0E208                           	;    RTS
0E208                           	;
0E208                           	;
0E208                           
0E208                           	pal_all:
0E208                           
0E208 85 2E                     		sta <PTR
0E20A 86 2F                     		stx <PTR+1
0E20C A2 00                     		ldx #$00
0E20E A9 20                     		lda #$20
0E210                           
0E210                           	
0E210                           
0E210                           	pal_copy:
0E210                           
0E210 85 30                     		sta <LEN
0E212 A0 00                     		ldy #$00
0E214                           	-
0E214 B1 2E                     		lda (PTR),y
0E216 9D 60 01                  		sta $0160,X   ;STA PAL_BUF,x
0E219 E8                        		inx
0E21A C8                        		iny
0E21B C6 30                     		dec <LEN
0E21D D0 F5                     		bne -
0E21F                           
0E21F E6 25                     		inc <palUpdate
0E221                           
0E221 20 D1 E0                  		jsr pal_bg_to_buf
0E224 4C 52 E1                  		jmp pal_spr_to_buf
0E227                           
0E227                           	
0E227                           
0E227                           	flushPalette:
0E227                           
0E227 A2 00                     		ldx #$00
0E229 A9 3F                     		lda #$3F
0E22B 8D 06 20                  		sta $2006
0E22E 8E 06 20                  		stx $2006
0E231                           
0E231                           		I=0
0E231                           		.rept 4
0E231                           		lda $0180+I
0E231                           		sta $2007
0E231                           		I=I+1
0E231 AD 80 01 8D 07 20 AD 81.. 		.endr
0E249                           
0E249                           		J=0
0E249                           		I=0
0E249                           		.rept 3
0E249                           		lda $2007            ;skip background color
0E249                           		.rept 3
0E249                           		lda $0180+5+(J*4)+I
0E249                           		sta $2007
0E249                           		I=I+1
0E249                           		.endr
0E249                           		I=0
0E249                           		J=J+1
0E249 AD 07 20 AD 85 01 8D 07.. 		.endr
0E288                           
0E288                           
0E288                           		J=0
0E288                           		I=0
0E288                           		.rept 3
0E288                           		lda $2007            ;skip background color
0E288                           		.rept 3
0E288                           		lda $0180+17+(J*4)+I
0E288                           		sta $2007
0E288                           		I=I+1
0E288                           		.endr
0E288                           		I=0
0E288                           		J=J+1
0E288 AD 07 20 AD 91 01 8D 07.. 		.endr
0E2C7                           
0E2C7                           		; clear 'flush-palette' flag
0E2C7 C6 25                     		dec palUpdate
0E2C9                           
0E2C9 60                        		rts
0E2CA                           
0E2CA                           	
0E2CA                           
0E2CA                           	fadePalette:
0E2CA                           		
0E2CA                           		; decrement palette fade counter
0E2CA C6 2D                     		dec palFadeCounter
0E2CC F0 01                     		beq +
0E2CE                           			; return
0E2CE 60                        			rts
0E2CF                           	+
0E2CF A5 2B                     		lda palFadeTo
0E2D1 C5 2A                     		cmp palBrightness
0E2D3                           		;bmi +
0E2D3 90 05                     		bcc +
0E2D5 E6 2A                     		inc palBrightness
0E2D7 4C DC E2                  		jmp ++
0E2DA                           	+
0E2DA C6 2A                     		dec palBrightness
0E2DC                           	++
0E2DC A5 2A                     		lda palBrightness
0E2DE 20 A4 E0                  		jsr setPaletteBrightness
0E2E1                           
0E2E1 A5 2B                     		lda palFadeTo
0E2E3 C5 2A                     		cmp palBrightness
0E2E5 F0 0B                     		beq +
0E2E7                           
0E2E7                           		; reset fade counter
0E2E7 A5 2C                     		lda palFadeDelay
0E2E9 85 2D                     		sta palFadeCounter
0E2EB                           
0E2EB                           		; set flags
0E2EB A9 81                     		lda #$81
0E2ED 85 25                     		sta palUpdate
0E2EF                           
0E2EF 4C 27 E2                  		jmp flushPalette
0E2F2                           
0E2F2                           	+
0E2F2                           		; palette faded
0E2F2 A9 01                     		lda #$01
0E2F4 85 25                     		sta palUpdate
0E2F6                           
0E2F6 4C 27 E2                  		jmp flushPalette
0E2F9                           
0E2F9                           	
0E2F9                           
0E2F9                           	fadePaletteNoWait:
0E2F9                           
0E2F9 85 2B                     		sta palFadeTo
0E2FB                           
0E2FB                           		; init fade counter
0E2FB A5 2C                     		lda palFadeDelay
0E2FD 85 2D                     		sta palFadeCounter
0E2FF                           
0E2FF                           		; set pal update status
0E2FF A9 80                     		lda #$80
0E301 85 25                     		sta palUpdate
0E303                           
0E303                           		; return
0E303 60                        		rts
0E304                           
0E304                           	
0E304                           
0E304                           	fadePaletteWait:
0E304                           
0E304 85 2B                     		sta palFadeTo
0E306                           
0E306                           		; init fade counter
0E306 A5 2C                     		lda palFadeDelay
0E308 85 2D                     		sta palFadeCounter
0E30A                           
0E30A                           		; set pal update status
0E30A A9 80                     		lda #$80
0E30C 85 25                     		sta palUpdate
0E30E                           
0E30E                           		; check palUpdate status - if 0 then update done
0E30E                           	-
0E30E 20 9D E0                  		jsr waitNMI
0E311 A5 25                     		lda palUpdate
0E313 D0 F9                     		bne -
0E315                           
0E315                           		; return
0E315 60                        		rts
0E316                           
0E316                           	
0E316                           
0E316                           	fillNT:
0E316                           		; argument(s) :
0E316                           		;   - A = nametable hi byte
0E316                           		;   - X = tile ID
0E316                           		; destroys :
0E316                           		;   - A
0E316                           		;   - X
0E316                           		;   - Y
0E316                           
0E316 8D 06 20                  		sta $2006
0E319 A9 00                     		lda #$00
0E31B 8D 06 20                  		sta $2006
0E31E                           
0E31E 8A                        		txa
0E31F A2 60                     		ldx #$60
0E321 A0 0A                     		ldy #$0A
0E323                           	-
0E323 8D 07 20                  		sta $2007
0E326 CA                        		dex
0E327 D0 FA                     		bne -
0E329 A2 60                     		ldx #$60
0E32B 88                        		dey
0E32C D0 F5                     		bne -
0E32E                           
0E32E                           		; return
0E32E 60                        		rts
0E32F                           
0E32F                           	
0E32F                           
0E32F                           	set_vram_update:
0E32F                           
0E32F 85 33                     		sta <NAME_UPD_ADR+0
0E331 86 34                     		stx <NAME_UPD_ADR+1
0E333 05 34                     		ora <NAME_UPD_ADR+1
0E335 85 32                     		sta <NAME_UPD_ENABLE
0E337                           
0E337 85 31                     		sta VRAM_UPDATE     ; added
0E339                           
0E339 60                        		rts
0E33A                           
0E33A                           	
0E33A                           
0E33A                           	flush_vram_update:
0E33A                           
0E33A 85 33                     		sta <NAME_UPD_ADR+0
0E33C 86 34                     		stx <NAME_UPD_ADR+1
0E33E                           
0E33E                           	
0E33E                           
0E33E                           	; VRAM update data format:
0E33E                           	; MSB, LSB, byte for a non-sequental write
0E33E                           	; MSB|NT_UPD_HORZ, LSB, LEN, [bytes] for a horizontal sequence
0E33E                           	; MSB|NT_UPD_VERT, LSB, LEN, [bytes] for a vertical sequence
0E33E                           	; NT_UPD_EOF to mark end of the buffer
0E33E                           
0E33E                           	;length of this data should be under 256 bytes
0E33E                           
0E33E                           	flush_vram_update_nmi:
0E33E                           
0E33E A0 00                     		ldy #0
0E340                           
0E340                           	updName:
0E340                           
0E340 B1 33                     		lda (NAME_UPD_ADR),y
0E342 C8                        		iny
0E343 C9 40                     		cmp #$40                ;is it a non-sequental write?
0E345 B0 12                     		bcs updNotSeq
0E347 8D 06 20                  		sta $2006
0E34A B1 33                     		lda (NAME_UPD_ADR),y
0E34C C8                        		iny
0E34D 8D 06 20                  		sta $2006
0E350 B1 33                     		lda (NAME_UPD_ADR),y
0E352 C8                        		iny
0E353 8D 07 20                  		sta $2007
0E356 4C 40 E3                  		jmp updName
0E359                           
0E359                           	updNotSeq:
0E359                           
0E359 AA                        		tax
0E35A A5 22                     		lda PPU_CTRL_VAR
0E35C E0 80                     		cpx #$80                ;is it a horizontal or vertical sequence?
0E35E 90 08                     		bcc updHorzSeq
0E360 E0 FF                     		cpx #$ff                ;is it end of the update?
0E362 F0 2A                     		beq updDone
0E364                           
0E364                           	updVertSeq:
0E364                           
0E364 09 04                     		ora #$04
0E366 D0 02                     		bne updNameSeq         ;bra
0E368                           
0E368                           	updHorzSeq:
0E368                           
0E368 29 FB                     		and #$fb
0E36A                           
0E36A                           	updNameSeq:
0E36A                           
0E36A 8D 00 20                  		sta $2000
0E36D                           
0E36D 8A                        		txa
0E36E 29 3F                     		and #$3f
0E370 8D 06 20                  		sta $2006
0E373 B1 33                     		lda (NAME_UPD_ADR),y
0E375 C8                        		iny
0E376 8D 06 20                  		sta $2006
0E379 B1 33                     		lda (NAME_UPD_ADR),y
0E37B C8                        		iny
0E37C AA                        		tax
0E37D                           
0E37D                           	updNameLoop:
0E37D                           
0E37D B1 33                     		lda (NAME_UPD_ADR),y
0E37F C8                        		iny
0E380 8D 07 20                  		sta $2007
0E383 CA                        		dex
0E384 D0 F7                     		bne updNameLoop
0E386                           
0E386 A5 22                     		lda PPU_CTRL_VAR
0E388 8D 00 20                  		sta $2000
0E38B                           
0E38B 4C 40 E3                  		jmp updName
0E38E                           
0E38E                           	updDone:
0E38E                           
0E38E A9 00                     		lda #$00
0E390 85 32                     		sta NAME_UPD_ENABLE
0E392                           
0E392 60                        		rts
0E393                           
0E393                           	
0E393                           
0E393                           	vram_unrle:
0E393                           
0E393                           		RLE_TAG     = $00
0E393                           		RLE_BYTE    = $01
0E393                           
0E393 A8                        		tay
0E394 86 2F                     		stx PTR+1
0E396 A9 00                     		lda #0
0E398 85 2E                     		sta PTR+0
0E39A                           
0E39A B1 2E                     		lda (PTR),y
0E39C 85 00                     		sta RLE_TAG
0E39E C8                        		iny
0E39F D0 02                     		bne -loop
0E3A1 E6 2F                     			inc PTR+1
0E3A3                           	-loop:
0E3A3                           
0E3A3 B1 2E                     		lda (PTR),y
0E3A5 C8                        		iny
0E3A6 D0 02                     		bne +
0E3A8 E6 2F                     			inc PTR+1
0E3AA                           	+
0E3AA                           
0E3AA C5 00                     		cmp RLE_TAG
0E3AC F0 07                     		beq +
0E3AE 8D 07 20                  			sta $2007
0E3B1 85 01                     			sta RLE_BYTE
0E3B3 D0 EE                     			bne -loop
0E3B5                           	+
0E3B5                           
0E3B5 B1 2E                     		lda (PTR),y
0E3B7 F0 10                     		beq done
0E3B9 C8                        		iny
0E3BA D0 02                     		bne +
0E3BC E6 2F                     			inc PTR+1
0E3BE                           	+
0E3BE                           
0E3BE AA                        		tax
0E3BF A5 01                     		lda RLE_BYTE
0E3C1                           
0E3C1                           	-
0E3C1 8D 07 20                  		sta $2007
0E3C4 CA                        		dex
0E3C5 D0 FA                     		bne -
0E3C7 F0 DA                     			beq -loop
0E3C9                           
0E3C9                           	done:
0E3C9                           
0E3C9 60                        		rts
0E3CA                           
0E3CA                           	
0E3CA                           
0E3CA                           	; ################################################################################
0E3CA                           	; DATAS
0E3CA                           
0E3CA                           	palBrightTableL:
0E3CA DC EC FC                  		.db <palBrightTable0,<palBrightTable1,<palBrightTable2
0E3CD 0C 1C 2C                  		.db <palBrightTable3,<palBrightTable4,<palBrightTable5
0E3D0 3C 4C 5C                  		.db <palBrightTable6,<palBrightTable7,<palBrightTable8
0E3D3                           	palBrightTableH:
0E3D3 E3 E3 E3                  		.db >palBrightTable0,>palBrightTable1,>palBrightTable2
0E3D6 E4 E4 E4                  		.db >palBrightTable3,>palBrightTable4,>palBrightTable5
0E3D9 E4 E4 E4                  		.db >palBrightTable6,>palBrightTable7,>palBrightTable8
0E3DC                           	palBrightTable0:
0E3DC 0F 0F 0F 0F 0F 0F 0F 0F.. 		.db $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f    ;black
0E3EC                           	palBrightTable1:
0E3EC 0F 0F 0F 0F 0F 0F 0F 0F.. 		.db $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f
0E3FC                           	palBrightTable2:
0E3FC 0F 0F 0F 0F 0F 0F 0F 0F.. 		.db $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f
0E40C                           	palBrightTable3:
0E40C 0F 0F 0F 0F 0F 0F 0F 0F.. 		.db $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f
0E41C                           	palBrightTable4:
0E41C 00 01 02 03 04 05 06 07.. 		.db $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0f,$0f,$0f    ;normal colors
0E42C                           	palBrightTable5:
0E42C 10 11 12 13 14 15 16 17.. 		.db $10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$1a,$1b,$1c,$00,$00,$00
0E43C                           	palBrightTable6:
0E43C 10 21 22 23 24 25 26 27.. 		.db $10,$21,$22,$23,$24,$25,$26,$27,$28,$29,$2a,$2b,$2c,$10,$10,$10    ;$10 because $20 is the same as $30
0E44C                           	palBrightTable7:
0E44C 30 31 32 33 34 35 36 37.. 		.db $30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$3a,$3b,$3c,$20,$20,$20
0E45C                           	palBrightTable8:
0E45C 30 30 30 30 30 30 30 30.. 		.db $30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30    ;white
0E46C 30 30 30 30 30 30 30 30.. 		.db $30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30
0E47C 30 30 30 30 30 30 30 30.. 		.db $30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30
0E48C 30 30 30 30 30 30 30 30.. 		.db $30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30
0E49C                           .include "nes-lib/system.asm"
0E49C                           ; ####################################################################################################
0E49C                           ; SYSTEM LIBRARY
0E49C                           
0E49C                           
0E49C                           
0E49C                               ; ####################################################################################################
0E49C                               ; CODE
0E49C                           
0E49C                               delayNMI:
0E49C                                   ; X = number of NMIs
0E49C                               -
0E49C 20 9D E0                          jsr waitNMI
0E49F CA                                dex
0E4A0 D0 FA                             bne -
0E4A2                           
0E4A2 60                                rts
0E4A3                               
0E4A3                           
0E4A3                               delayFrame:
0E4A3                                   ; X = number of frames
0E4A3                               -
0E4A3 20 8C E0                          jsr waitFrame
0E4A6 CA                                dex
0E4A7 D0 FA                             bne -
0E4A9                           
0E4A9 60                                rts
0E4AA                               
0E4AA                           
0E4AA                               div16_16:
0E4AA                           
0E4AA                               divide:
0E4AA A9 00                             lda #0          ;preset remainder to 0
0E4AC 85 03                             sta $03
0E4AE 85 04                             sta $03+1
0E4B0 A2 10                             ldx #16         ;repeat for each bit: ...
0E4B2                           
0E4B2                               divloop:
0E4B2 06 01                             asl $01    ;dividend lb & hb*2, msb -> Carry
0E4B4 26 02                             rol $01+1  
0E4B6 26 03                             rol $03   ;remainder lb & hb * 2 + msb from carry
0E4B8 26 04                             rol $03+1
0E4BA A5 03                             lda $03
0E4BC 38                                sec
0E4BD E5 00                             sbc $00     ;substract divisor to see if it fits in
0E4BF A8                                tay             ;lb result -> Y, for we may need it later
0E4C0 A5 04                             lda $03+1
0E4C2 E5 01                             sbc $00+1
0E4C4 90 06                             bcc skip        ;if carry=0 then divisor didn't fit in yet
0E4C6                           
0E4C6 85 04                             sta $03+1 ;else save substraction result as new remainder,
0E4C8 84 03                             sty $03   
0E4CA E6 01                             inc $01      ;and INCrement result cause divisor fit in 1 times
0E4CC                           
0E4CC                               skip:
0E4CC CA                                dex
0E4CD D0 E3                             bne divloop
0E4CF                           
0E4CF 60                                rts
0E4D0                           
0E4D0                               
0E4D0                           
0E4D0                               ; prng
0E4D0                               ; 
0E4D0                               ; Returns a random 8-bit number in A (0-255), clobbers X (0).
0E4D0                               ; 
0E4D0                               ; Requires a 2-byte value on the zero page called "seed".
0E4D0                               ; Initialize seed to any value except 0 before the first call to prng.
0E4D0                               ; (A seed value of 0 will cause prng to always return 0.)
0E4D0                               ; 
0E4D0                               ; This is a 16-bit Galois linear feedback shift register with polynomial $002D.
0E4D0                               ; The sequence of numbers it generates will repeat after 65535 calls.
0E4D0                               ; 
0E4D0                               ; The value loaded in X controls the quality of randomness. Each iteration produces another bit worth of entropy.
0E4D0                               ; 8 bits will produce maximum entropy, but this value can be lowered to increase speed.
0E4D0                               ; Valid values are 8, 7, 4, 2, 1. (Avoid 6, 5 and 3, as they shorten the sequence by having common factors with 65535.)
0E4D0                               ; 
0E4D0                               ; Execution time is an average of 125 cycles (excluding jsr and rts)
0E4D0                               ; https://wiki.nesdev.com/w/index.php/Random_number_generator
0E4D0                               prng:
0E4D0 A2 08                             ldx #8     ; iteration count: controls entropy quality (max 8,7,4,2,1 min)
0E4D2 A5 35                             lda seed+0
0E4D4                               -
0E4D4 0A                                asl        ; shift the register
0E4D5 26 36                             rol seed+1
0E4D7 90 02                             bcc +
0E4D9 49 2D                             eor #$2D   ; apply XOR feedback whenever a 1 bit is shifted out
0E4DB                               +
0E4DB CA                                dex
0E4DC D0 F6                             bne -
0E4DE 85 35                             sta seed+0
0E4E0 C9 00                             cmp #0     ; reload flags
0E4E2 60                                rts
0E4E3                               
0E4E3                           .include "nes-lib/pad.asm"0E4E3                           ; ####################################################################################################
0E4E3                           ; PAD LIBRARY
0E4E3                           
0E4E3                           ; ####################################################################################################
0E4E3                           ; CODE
0E4E3                           
0E4E3                           padRead:
0E4E3                           
0E4E3                           ; Y = controller # ( 0 | 1 )
0E4E3                           
0E4E3 A5 3F                     	lda padState
0E4E5 85 3E                     	sta padStateOld         ; save previous joypad data
0E4E7 A9 7F                     	lda #%01111111
0E4E9 85 3F                     	sta padState
0E4EB 8D 16 40                  	sta $4016
0E4EE 0A                        	asl A
0E4EF 8D 16 40                  	sta $4016
0E4F2                           	-
0E4F2 B9 16 40                  	lda $4016,y
0E4F5 29 03                     	and #$03                ; props to Disch for Famicon support
0E4F7 C9 01                     	cmp #$01
0E4F9 66 3F                     	ror padState            ; right, left, down, up, start, select, B, A
0E4FB B0 F5                     	bcs -
0E4FD                           
0E4FD A9 00                     	lda #0
0E4FF 8D 16 40                  	sta $4016
0E502 A9 01                     	lda #1
0E504 8D 16 40                  	sta $4016
0E507                           
0E507 A5 3E                     	lda padStateOld
0E509 49 FF                     	eor #$FF
0E50B 25 3F                     	and padState
0E50D 85 40                     	sta padPressed          ; this tracks off-to-on transitions.
0E50F                           
0E50F A5 3F                     	lda padState
0E511 49 FF                     	eor #$FF
0E513 25 3E                     	and padStateOld
0E515 85 41                     	sta padReleased         ; this tracks on-to-off transitions
0E517                           
0E517 A5 3F                     	lda padState
0E519                           
0E519 60                        	rts
0E51A                           
0E51A                           ; RAINBOW
0E51A                           ; documentation: https://github.com/BrokeStudio/rainbow-lib
0E51A                           .include "rainbow-lib/rainbow.asm"
0E51A                           ; ################################################################################
0E51A                           ; RAINBOW LIBRARY
0E51A                           
0E51A                           ; ################################################################################
0E51A                           ; INCLUDES
0E51A                           
0E51A                             .include "rainbow-lib/rainbow-config.asm"
0E51A                           ; ################################################################################
0E51A                           ; RAINBOW CONSTANTS
0E51A                           
0E51A                           RNBW_BUF_IN        EQU $4800
0E51A                           RNBW_BUF_OUT       EQU ($4800 + 256)
0E51A                             .include "rainbow-lib/rainbow-constants.asm"
0E51A                           ; ################################################################################
0E51A                           ; RAINBOW CONSTANTS
0E51A                           
0E51A                           ; mapper registers
0E51A                           RNBW_CONFIG    EQU $4100
0E51A                           RNBW_RX        EQU $4101
0E51A                           RNBW_TX        EQU $4102
0E51A                           RNBW_RX_ADD    EQU $4103
0E51A                           RNBW_TX_ADD    EQU $4104
0E51A                           
0E51A                           ; commands to ESP
0E51A                           
0E51A                           ; ESP CMDS
0E51A                           TOESP_ESP_GET_STATUS                  EQU 0   ; Get ESP status
0E51A                           TOESP_DEBUG_GET_LEVEL                 EQU 1   ; Get debug level
0E51A                           TOESP_DEBUG_SET_LEVEL                 EQU 2   ; Set debug level
0E51A                           TOESP_DEBUG_LOG                       EQU 3   ; Debug / Log data
0E51A                           TOESP_CLEAR_BUFFERS                   EQU 4   ; Clear RX/TX buffers
0E51A                           TOESP_FROMESP_BUFFER_DROP_FROM_ESP    EQU 5   ; Drop messages from ESP buffer (TX)
0E51A                           TOESP_ESP_GET_FIRMWARE_VERSION        EQU 6   ; Get ESP/Rainbow firmware version
0E51A                           TOESP_ESP_RESTART                     EQU 7   ; Restart ESP
0E51A                           
0E51A                           ; WIFI CMDS
0E51A                           TOESP_WIFI_GET_STATUS                 EQU 8   ; Get WiFi connection status
0E51A                           TOESP_WIFI_GET_SSID                   EQU 9   ; Get WiFi network SSID
0E51A                           TOESP_WIFI_GET_IP                     EQU 10  ; Get WiFi IP address
0E51A                           
0E51A                           ; ACESS POINT CMDS
0E51A                           TOESP_AP_GET_SSID                     EQU 11  ; Get Access Point network SSID
0E51A                           TOESP_AP_GET_IP                       EQU 12  ; Get Access Point IP address
0E51A                           TOESP_AP_GET_CONFIG                   EQU 13  ; Get Access Point config
0E51A                           TOESP_AP_SET_CONFIG                   EQU 14  ; Set Access Point config
0E51A                           
0E51A                           ; RND CMDS
0E51A                           TOESP_RND_GET_BYTE                    EQU 15  ; Get random byte
0E51A                           TOESP_RND_GET_BYTE_RANGE              EQU 16  ; Get random byte between custom min/max
0E51A                           TOESP_RND_GET_WORD                    EQU 17  ; Get random word
0E51A                           TOESP_RND_GET_WORD_RANGE              EQU 18  ; Get random word between custom min/max
0E51A                           
0E51A                           ; SERVER CMDS
0E51A                           TOESP_SERVER_GET_STATUS               EQU 19  ; Get server connection status
0E51A                           TOESP_SERVER_PING                     EQU 20  ; Get ping between ESP and server
0E51A                           TOESP_SERVER_SET_PROTOCOL             EQU 21  ; Set protocol to be used to communicate (WS/UDP/TCP)
0E51A                           TOESP_SERVER_GET_SETTINGS             EQU 22  ; Get current server host name and port
0E51A                           TOESP_SERVER_GET_CONFIG_SETTINGS      EQU 23  ; Get server host name and port defined in the Rainbow config file
0E51A                           TOESP_SERVER_SET_SETTINGS             EQU 24  ; Set current server host name and port
0E51A                           TOESP_SERVER_RESTORE_SETTINGS         EQU 25  ; Restore server host name and port to values defined in the Rainbow config
0E51A                           TOESP_SERVER_CONNECT                  EQU 26  ; Connect to server
0E51A                           TOESP_SERVER_DISCONNECT               EQU 27  ; Disconnect from server
0E51A                           TOESP_SERVER_SEND_MSG                 EQU 28  ; Send message to rainbow server
0E51A                           
0E51A                           ; NETWORK CMDS
0E51A                           TOESP_NETWORK_SCAN                    EQU 29  ; Scan networks around and return count
0E51A                           TOESP_NETWORK_GET_SCANNED_DETAILS     EQU 30  ; Get scanned network details
0E51A                           TOESP_NETWORK_GET_REGISTERED          EQU 31  ; Get registered networks status
0E51A                           TOESP_NETWORK_GET_REGISTERED_DETAILS  EQU 32  ; Get registered network SSID
0E51A                           TOESP_NETWORK_REGISTER                EQU 33  ; Register network
0E51A                           TOESP_NETWORK_UNREGISTER              EQU 34  ; Unregister network
0E51A                           
0E51A                           ; FILE COMMANDS
0E51A                           TOESP_FILE_OPEN                       EQU 35  ; Open working file
0E51A                           TOESP_FILE_CLOSE                      EQU 36  ; Close working file
0E51A                           TOESP_FILE_STATUS                     EQU 37  ; Get working file status
0E51A                           TOESP_FILE_EXISTS                     EQU 38  ; Check if file exists
0E51A                           TOESP_FILE_DELETE                     EQU 39  ; Delete a file
0E51A                           TOESP_FILE_SET_CUR                    EQU 40  ; Set working file cursor position a file
0E51A                           TOESP_FILE_READ                       EQU 41  ; Read working file (at specific position)
0E51A                           TOESP_FILE_WRITE                      EQU 42  ; Write working file (at specific position)
0E51A                           TOESP_FILE_APPEND                     EQU 43  ; Append data to working file
0E51A                           TOESP_FILE_COUNT                      EQU 44  ; Count files in a specific path
0E51A                           TOESP_FILE_GET_LIST                   EQU 45  ; Get list of existing files in a path
0E51A                           TOESP_FILE_GET_FREE_ID                EQU 46  ; Get an unexisting file ID in a specific path
0E51A                           TOESP_FILE_GET_INFO                   EQU 47  ; Get file info (size + crc32)
0E51A                           TOESP_FILE_DOWNLOAD                   EQU 48  ; Download a file
0E51A                           TOESP_FILE_FORMAT                     EQU 49  ; Format file system and save current config
0E51A                           
0E51A                           ; commands from ESP
0E51A                           
0E51A                           ; ESP CMDS
0E51A                           FROMESP_READY                         EQU 0   ; ESP is ready
0E51A                           FROMESP_DEBUG_LEVEL                   EQU 1   ; Returns debug configuration
0E51A                           FROMESP_ESP_FIRMWARE_VERSION          EQU 2   ; Returns ESP/Rainbow firmware version
0E51A                           
0E51A                           ; WIFI / AP CMDS
0E51A                           FROMESP_WIFI_STATUS                   EQU 3   ; Returns WiFi connection status
0E51A                           FROMESP_SSID                          EQU 4   ; Returns WiFi / AP SSID
0E51A                           FROMESP_IP                            EQU 5   ; Returns WiFi / AP IP address
0E51A                           FROMESP_AP_CONFIG                     EQU 6   ; Returns AP config
0E51A                           
0E51A                           ; RND CMDS
0E51A                           FROMESP_RND_BYTE                      EQU 7   ; Returns random byte value
0E51A                           FROMESP_RND_WORD                      EQU 8   ; Returns random word value
0E51A                           
0E51A                           ; SERVER CMDS
0E51A                           FROMESP_SERVER_STATUS                 EQU 9   ; Returns server connection status
0E51A                           FROMESP_SERVER_PING                   EQU 10   ; Returns min, max and average round-trip time and number of lost packets
0E51A                           FROMESP_SERVER_SETTINGS               EQU 11  ; Returns server settings (host name + port)
0E51A                           FROMESP_MESSAGE_FROM_SERVER           EQU 12  ; Message from server
0E51A                           
0E51A                           ; NETWORK CMDS
0E51A                           FROMESP_NETWORK_COUNT                 EQU 13  ; Returns number of networks found
0E51A                           FROMESP_NETWORK_SCANNED_DETAILS       EQU 14  ; Returns details for a scanned network
0E51A                           FROMESP_NETWORK_REGISTERED_DETAILS    EQU 15  ; Returns SSID for a registered network
0E51A                           FROMESP_NETWORK_REGISTERED            EQU 16  ; Returns registered networks status
0E51A                           
0E51A                           ; FILE CMDS
0E51A                           FROMESP_FILE_STATUS                   EQU 17  ; Returns working file status
0E51A                           FROMESP_FILE_EXISTS                   EQU 18  ; Returns if file exists or not
0E51A                           FROMESP_FILE_DELETE                   EQU 19  ; See RNBW_FILE_DELETE_xxx constants for details on returned value
0E51A                           FROMESP_FILE_LIST                     EQU 20  ; Returns path file list (FILE_GET_LIST)
0E51A                           FROMESP_FILE_DATA                     EQU 21  ; Returns file data (FILE_READ)
0E51A                           FROMESP_FILE_COUNT                    EQU 22  ; Returns file count in a specific path
0E51A                           FROMESP_FILE_ID                       EQU 23  ; Returns a free file ID (FILE_GET_FREE_ID)
0E51A                           FROMESP_FILE_INFO                     EQU 24  ; Returns file info (size + CRC32) (FILE_GET_INFO)
0E51A                           FROMESP_FILE_DOWNLOAD                 EQU 25  ; See RNBW_FILE_DOWNLOAD_xxx constants for details on returned value
0E51A                           
0E51A                           ; WiFi status
0E51A                           RNBW_WIFI_NO_SHIELD EQU 255
0E51A                           RNBW_WIFI_IDLE_STATUS EQU 0
0E51A                           RNBW_WIFI_NO_SSID_AVAIL EQU 1
0E51A                           RNBW_WIFI_SCAN_COMPLETED EQU 2
0E51A                           RNBW_WIFI_CONNECTED EQU 3
0E51A                           RNBW_WIFI_CONNECT_FAILED EQU 4
0E51A                           RNBW_WIFI_CONNECTION_LOST EQU 5
0E51A                           RNBW_WIFI_DISCONNECTED EQU 6
0E51A                           
0E51A                           ; Server protocols
0E51A                           RNBW_PROTOCOL_WEBSOCKET EQU 0
0E51A                           RNBW_PROTOCOL_WEBSOCKET_SECURED EQU 1
0E51A                           RNBW_PROTOCOL_TCP EQU 2
0E51A                           RNBW_PROTOCOL_TCP_SECURED EQU 3
0E51A                           RNBW_PROTOCOL_UDP EQU 4
0E51A                           
0E51A                           ; Server status
0E51A                           RNBW_SERVER_DISCONNECTED EQU 0
0E51A                           RNBW_SERVER_CONNECTED EQU 1
0E51A                           
0E51A                           ; File paths
0E51A                           RNBW_FILE_PATH_SAVE EQU 0
0E51A                           RNBW_FILE_PATH_ROMS EQU 1
0E51A                           RNBW_FILE_PATH_USER EQU 2
0E51A                           
0E51A                           ; File constants
0E51A                           RNBW_NUM_PATHS EQU 3
0E51A                           RNBW_NUM_FILES EQU 64
0E51A                           
0E51A                           ; Network encryption types
0E51A                           RNBW_NETWORK_ENCTYPE_WEP EQU 5
0E51A                           RNBW_NETWORK_ENCTYPE_WPA_PSK EQU 2
0E51A                           RNBW_NETWORK_ENCTYPE_WPA2_PSK EQU 4
0E51A                           RNBW_NETWORK_ENCTYPE_OPEN_NETWORK EQU 7
0E51A                           RNBW_NETWORK_ENCTYPE_WPA_WPA2_PSK EQU 8
0E51A                           
0E51A                           ; File config masks/flags
0E51A                           RNBW_FILE_CONFIG_FLAGS_ACCESS_MODE_MASK EQU %00000001
0E51A                           RNBW_FILE_CONFIG_FLAGS_AUTO_ACCESS_MODE EQU 0
0E51A                           RNBW_FILE_CONFIG_FLAGS_MANUAL_ACCESS_MODE EQU 1
0E51A                           
0E51A                           ; FILE_DELETE result codes
0E51A                           RNBW_FILE_DELETE_SUCCESS EQU 0
0E51A                           RNBW_FILE_DELETE_ERROR_WHILE_DELETING_FILE EQU 1
0E51A                           RNBW_FILE_DELETE_FILE_NOT_FOUND EQU 2
0E51A                           RNBW_FILE_DELETE_INVALID_PATH_OR_FILE EQU 3
0E51A                           
0E51A                           ; FILE_DOWNLOAD result codes
0E51A                           RNBW_FILE_DOWNLOAD_SUCCESS EQU 0
0E51A                           RNBW_FILE_DOWNLOAD_INVALID_DESTINATION EQU 1
0E51A                           RNBW_FILE_DOWNLOAD_ERROR_WHILE_DELETING_FILE EQU 2
0E51A                           RNBW_FILE_DOWNLOAD_UNKNOWN_OR_UNSUPPORTED_PROTOCOL EQU 3
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERROR EQU 4
0E51A                           RNBW_FILE_DOWNLOAD_HTTP_STATUS_NOT_IN_2XX EQU 5
0E51A                           
0E51A                           ; FILE_DOWNLOAD network error codes
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_CONNECTION_FAILED EQU -1
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_SEND_HEADER_FAILED EQU -2
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_SEND_PAYLOAD_FAILED EQU -3
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_NOT_CONNECTED EQU -4
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_CONNECTION_LOST EQU -5
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_NO_STREAM EQU -6
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_NO_HTTP_SERVER EQU -7
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_TOO_LESS_RAM EQU -8
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_ENCODING EQU -9
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_STREAM_WRITE EQU -10
0E51A                           RNBW_FILE_DOWNLOAD_NETWORK_ERR_READ_TIMEOUT EQU -11
0E51A                           
0E51A                           ; ################################################################################
0E51A                           ; ALIASES
0E51A                           
0E51A                           ; ################################################################################
0E51A                           ; ZEROPAGE
0E51A                           
0E51A                             ;.enum $0000
0E51A                             ;rnbwTmp  .dsb 2
0E51A                             ;.ende
0E51A                             rnbwTmp  EQU $fe
0E51A                           
0E51A                           ; ################################################################################
0E51A                           ; MACROS
0E51A                           
0E51A                             .macro RNBW_waitRX
0E51A                               ; wait for message to be received
0E51A                             -
0E51A                               bit $4101
0E51A                               bpl -
0E51A                             .endm
0E51A                           
0E51A                             .macro RNBW_waitTX
0E51A                               ; wait for message to be sent
0E51A                             -
0E51A                               bit $4102
0E51A                               bpl -
0E51A                             .endm
0E51A                           
0E51A                           ; ################################################################################
0E51A                           ; CODE
0E51A                           
0E51A                             RNBW_disableIRQ:
0E51A                           
0E51A                               ; disable ESP IRQ
0E51A AD 00 41                      lda $4100
0E51D 29 FD                         and #$fd
0E51F 8D 00 41                      sta $4100
0E522                           
0E522                               ; return
0E522 60                            rts
0E523                           
0E523                             
0E523                           
0E523                             RNBW_enableIRQ:
0E523                           
0E523                               ; enable ESP IRQ
0E523 AD 00 41                      lda $4100
0E526 09 02                         ora #$02
0E528 8D 00 41                      sta $4100
0E52B                           
0E52B                               ; return
0E52B 60                            rts
0E52C                           
0E52C                             
0E52C                           
0E52C                             RNBW_sendData:
0E52C                               ; A: message pointer lo byte
0E52C                               ; X: message pointer hi byte
0E52C                           
0E52C 85 FE                         sta $fe+0
0E52E 86 FF                         stx $fe+1
0E530                           
0E530 A0 00                         ldy #0
0E532 B1 FE                         lda ($fe),y
0E534 AA                            tax
0E535 E8                            inx
0E536                             -
0E536 B1 FE                         lda ($fe),y
0E538 99 00 49                      sta ($4800 + 256),y
0E53B C8                            iny
0E53C CA                            dex
0E53D D0 F7                         bne -
0E53F 8D 02 41                      sta $4102
0E542                           
0E542                             -
0E542 2C 02 41                      bit $4102
0E545 10 FB                         bpl -
0E547                           
0E547                               ; return
0E547 60                            rts
0E548                             
0E548                           
0E548                             RNBW_waitReady:
0E548                           
0E548                               ; ask for ESP status
0E548 A9 01                         lda #1
0E54A 8D 00 49                      sta ($4800 + 256)+0
0E54D A9 00                         lda #0
0E54F 8D 01 49                      sta ($4800 + 256)+1
0E552 8D 02 41                      sta $4102
0E555                           
0E555                               ; wait for message to be sent
0E555                             -
0E555 2C 02 41                      bit $4102
0E558 10 FB                         bpl -
0E55A                           
0E55A                               ; wait for answer
0E55A                             -
0E55A 2C 01 41                      bit $4101
0E55D 10 FB                         bpl -
0E55F                           
0E55F                               ; acknowledge answer
0E55F 8D 01 41                      sta $4101
0E562                           
0E562                               ; return
0E562 60                            rts
0E563                           
0E563                             
0E563                           
0E563                             RNBW_copyRXtoTX:
0E563                           
0E563                               ; copy RX buffer to TX buffer
0E563 AE 00 48                      ldx $4800+0
0E566 8E 00 49                      stx ($4800 + 256)+0
0E569                             -
0E569 BD 00 48                      lda $4800,x
0E56C 9D 00 49                      sta ($4800 + 256),x
0E56F CA                            dex
0E570 D0 F7                         bne -
0E572                           
0E572                               ; return
0E572 60                            rts
0E573                           
0E573                             
0E573                           
0E573                             RNBW_debug_A:
0E573                               
0E573                               ; data to debug in A
0E573 48                            pha
0E574 A9 02                         lda #2
0E576 8D 00 49                      sta ($4800 + 256)+0
0E579 A9 03                         lda #3
0E57B 8D 01 49                      sta ($4800 + 256)+1
0E57E 68                            pla
0E57F 8D 02 49                      sta ($4800 + 256)+2
0E582 8D 02 41                      sta $4102
0E585                           
0E585                               ; wait for message to be sent
0E585                             -
0E585 2C 02 41                      bit $4102
0E588 10 FB                         bpl -
0E58A                           
0E58A                               ; return
0E58A 60                            rts
0E58B                           
0E58B                             
0E58B                           
0E58B                             RNBW_debug_X:
0E58B                           
0E58B                               ; data to debug in X
0E58B A9 02                         lda #2
0E58D 8D 00 49                      sta ($4800 + 256)+0
0E590 A9 03                         lda #3
0E592 8D 01 49                      sta ($4800 + 256)+1
0E595 8E 02 49                      stx ($4800 + 256)+2
0E598 8D 02 41                      sta $4102
0E59B                           
0E59B                               ; wait for message to be sent
0E59B                             -
0E59B 2C 02 41                      bit $4102
0E59E 10 FB                         bpl -
0E5A0                           
0E5A0                               ; return
0E5A0 60                            rts
0E5A1                           
0E5A1                             
0E5A1                           
0E5A1                             RNBW_debug_Y:
0E5A1                             
0E5A1                               ; data to debug in Y
0E5A1 A9 02                         lda #2
0E5A3 8D 00 49                      sta ($4800 + 256)+0
0E5A6 A9 03                         lda #3
0E5A8 8D 01 49                      sta ($4800 + 256)+1
0E5AB 8C 02 49                      sty ($4800 + 256)+2
0E5AE 8D 02 41                      sta $4102
0E5B1                           
0E5B1                               ; wait for message to be sent
0E5B1                             -
0E5B1 2C 02 41                      bit $4102
0E5B4 10 FB                         bpl -
0E5B6                           
0E5B6                               ; return
0E5B6 60                            rts
0E5B7                           
0E5B7                             
0E5B7                           
0E5B7                             RNBW_getWifiStatus:
0E5B7                           
0E5B7                               ; ask for wifi status
0E5B7 A9 01                         lda #1
0E5B9 8D 00 49                      sta ($4800 + 256)+0
0E5BC A9 08                         lda #8
0E5BE 8D 01 49                      sta ($4800 + 256)+1
0E5C1 8D 02 41                      sta $4102
0E5C4                           
0E5C4                               ; wait for message to be sent
0E5C4                             -
0E5C4 2C 02 41                      bit $4102
0E5C7 10 FB                         bpl -
0E5C9                           
0E5C9                               ; wait for answer
0E5C9                             -
0E5C9 2C 01 41                      bit $4101
0E5CC 10 FB                         bpl -
0E5CE                           
0E5CE                               ; return wifi status in A
0E5CE AD 02 48                      lda $4800+2
0E5D1                           
0E5D1                               ; acknowledge answer
0E5D1 8D 01 41                      sta $4101
0E5D4                           
0E5D4                               ; return
0E5D4 60                            rts
0E5D5                           
0E5D5                             
0E5D5                           
0E5D5                             RNBW_getServerStatus:
0E5D5                           
0E5D5                               ; ask for server status
0E5D5 A9 01                         lda #1
0E5D7 8D 00 49                      sta ($4800 + 256)+0
0E5DA A9 13                         lda #19
0E5DC 8D 01 49                      sta ($4800 + 256)+1
0E5DF 8D 02 41                      sta $4102
0E5E2                           
0E5E2                               ; wait for message to be sent
0E5E2                             -
0E5E2 2C 02 41                      bit $4102
0E5E5 10 FB                         bpl -
0E5E7                           
0E5E7                               ; wait for answer
0E5E7                             -
0E5E7 2C 01 41                      bit $4101
0E5EA 10 FB                         bpl -
0E5EC                           
0E5EC                               ; return server status in A
0E5EC AD 02 48                      lda $4800+2
0E5EF                           
0E5EF                               ; acknowledge answer
0E5EF 8D 01 41                      sta $4101
0E5F2                           
0E5F2                               ; return
0E5F2 60                            rts
0E5F3                           
0E5F3                             
0E5F3                           
0E5F3                             RNBW_getRandomByte:
0E5F3                           
0E5F3 A9 01                         lda #1
0E5F5 8D 00 49                      sta ($4800 + 256)+0
0E5F8 A9 0F                         lda #15
0E5FA 8D 01 49                      sta ($4800 + 256)+1
0E5FD 8D 02 41                      sta $4102
0E600                           
0E600                               ; wait for message to be sent
0E600                             -
0E600 2C 02 41                      bit $4102
0E603 10 FB                         bpl -
0E605                           
0E605                               ; wait for answer
0E605                             -
0E605 2C 01 41                      bit $4101
0E608 10 FB                         bpl -
0E60A                           
0E60A                               ; return random byte in A
0E60A AD 02 48                      lda $4800+2
0E60D                           
0E60D                               ; acknowledge answer
0E60D 8D 01 41                      sta $4101
0E610                           
0E610                               ; return
0E610 60                            rts
0E611                           
0E611                             
0E611                           
0E611                             RNBW_getRandomByteRange:
0E611                               ; X: min
0E611                               ; Y: max
0E611                           
0E611 A9 03                         lda #3
0E613 8D 00 49                      sta ($4800 + 256)+0
0E616 A9 10                         lda #16
0E618 8D 01 49                      sta ($4800 + 256)+1
0E61B 8E 02 49                      stx ($4800 + 256)+2
0E61E 8C 03 49                      sty ($4800 + 256)+3
0E621 8D 02 41                      sta $4102    
0E624                           
0E624                               ; wait for message to be sent
0E624                             -
0E624 2C 02 41                      bit $4102
0E627 10 FB                         bpl -
0E629                           
0E629                               ; wait for answer
0E629                             -
0E629 2C 01 41                      bit $4101
0E62C 10 FB                         bpl -
0E62E                           
0E62E                               ; return random byte in A
0E62E AD 02 48                      lda $4800+2
0E631                           
0E631                               ; acknowledge answer
0E631 8D 01 41                      sta $4101
0E634                           
0E634                               ; return
0E634 60                            rts
0E635                           
0E635                             
0E635                           
0E635                             RNBW_getRandomWord:
0E635                           
0E635 A9 01                         lda #1
0E637 8D 00 49                      sta ($4800 + 256)+0
0E63A A9 11                         lda #17
0E63C 8D 01 49                      sta ($4800 + 256)+1
0E63F 8D 02 41                      sta $4102    
0E642                           
0E642                               ; wait for message to be sent
0E642                             -
0E642 2C 02 41                      bit $4102
0E645 10 FB                         bpl -
0E647                           
0E647                               ; wait for answer
0E647                             -
0E647 2C 01 41                      bit $4101
0E64A 10 FB                         bpl -
0E64C                           
0E64C                               ; return random word in A (hi) and X (lo)
0E64C AD 02 48                      lda $4800+2
0E64F AE 03 48                      ldx $4800+3
0E652                           
0E652                               ; acknowledge answer
0E652 8D 01 41                      sta $4101
0E655                           
0E655                               ; return
0E655 60                            rts
0E656                           
0E656                             
0E656                           
0E656                           ; CHAT
0E656                           .include "chat.asm"
0E656                           ; ################################################################################
0E656                           ; CONSTANTS
0E656                           
0E656                           ; uncomment this line to use hardcoded server hostname and port
0E656                           ; see chatConnect in chat-connections.asm file
0E656                           localhost EQU 1
0E656                           
0E656                           ; ################################################################################
0E656                           ; ZEROPAGE + MISC
0E656                           
0E656                           .enum $0050
00050                           
00050                           cursorPos      .dsb 1  ; cursor position / index
00051                           cursorHoldCnt  .dsb 1  ; cursor hold counter
00052                           textCursorPos  .dsb 1  ; text cursor postion / index
00053                           separatorPos   .dsb 1  ; separator position between username and actual message
00054                           usernameLength .dsb 1  ; username length
00055                           messageLength  .dsb 1  ; message length
00056                           messageEnd     .dsb 1  ; message end index
00057                           NTaddress      .dsb 2  ; NT VRAM address to update
00059                           chatState      .dsb 1  ; chat state (HOSTNAME | PORT | USERNAME | CHAT)
0005A                           
0005A                           ; chat-settings
0005A                           username       .dsb 8  ; username string, max  8 characters
00062                           hostname       .dsb 32 ; hostname string, max 32 characters
00082                           hostnameLength .dsb 1  ; hostname length
00083                           port           .dsb 2  ; port (converted from string to 16bit hex)
00085                           
00085                           .ende
0E656                           
0E656                           CURSOR_TILE         EQU $1e
0E656                           CURSOR_MAX_POS      EQU 90
0E656                           CURSOR_HOLD_DELAY   EQU 30
0E656                           TEXT_MAX_LENGTH     EQU 28
0E656                           
0E656                           CHAT_STATES_HOSTNAME  EQU 0
0E656                           CHAT_STATES_PORT      EQU 1
0E656                           CHAT_STATES_USERNAME  EQU 2
0E656                           CHAT_STATES_CHAT      EQU 3
0E656                           
0E656                           ; ################################################################################
0E656                           ; INCLUDES
0E656                           
0E656                           .include "chat-settings.asm"
0E656                           ; ################################################################################
0E656                           ; CODE
0E656                           
0E656                           setHostnameInit:
0E656                           
0E656                             ; display "enter host..." text
0E656 A9 38                       lda #<txtServerHostname
0E658 A2 E7                       ldx #>txtServerHostname
0E65A 20 2F E3                    jsr set_vram_update
0E65D                           
0E65D                             ; update chat state
0E65D A9 00                       lda #0
0E65F 85 59                       sta chatState
0E661                           
0E661                             ; return
0E661 60                          rts
0E662                           
0E662                           
0E662                           
0E662                           setHostname:
0E662                           
0E662                             ; get hostname length
0E662 A5 52                       lda textCursorPos
0E664 D0 01                       bne +
0E666                               ; if string is empty, abort...
0E666 60                            rts
0E667                           +
0E667 85 82                       sta hostnameLength
0E669                           
0E669                             ; copy hostname string
0E669 A2 00                       ldx #0
0E66B                           -
0E66B BD 03 49                    lda ($4800 + 256)+3,x
0E66E 95 62                       sta hostname,x
0E670 E8                          inx
0E671 E4 82                       cpx hostnameLength
0E673 D0 F6                       bne -
0E675                           
0E675 4C 78 E6                    jmp setPortInit
0E678                           
0E678                           
0E678                           
0E678                           setPortInit:
0E678                           
0E678                             ; display "enter port..." text
0E678 A9 5C                       lda #<txtServerPort
0E67A A2 E7                       ldx #>txtServerPort
0E67C 20 2F E3                    jsr set_vram_update
0E67F 20 9D E0                    jsr waitNMI
0E682                           
0E682                             ; clear text input
0E682 A9 6A                       lda #<txtBlank
0E684 A2 ED                       ldx #>txtBlank
0E686 20 2F E3                    jsr set_vram_update
0E689 20 9D E0                    jsr waitNMI
0E68C                           
0E68C                             ; reset text cursor
0E68C A2 00                       ldx #0
0E68E 86 52                       stx textCursorPos
0E690                             
0E690                             ; update NT VRAM address
0E690 BD 8A ED                    lda NTaddressHI,x
0E693 8D 00 01                    sta $100
0E696 BD A6 ED                    lda NTaddressLO,x
0E699 8D 01 01                    sta $101
0E69C                           
0E69C                             ; update chat state
0E69C A9 01                       lda #1
0E69E 85 59                       sta chatState
0E6A0                           
0E6A0                             ; return
0E6A0 60                          rts
0E6A1                           
0E6A1                           
0E6A1                           
0E6A1                           setPort:
0E6A1                           
0E6A1                             strPort = $400
0E6A1                           
0E6A1                             ; reverse string and convert each digit to hex value
0E6A1 A6 52                       ldx textCursorPos
0E6A3 D0 01                       bne +
0E6A5                               ; string empty, abort...
0E6A5 60                            rts
0E6A6                           +
0E6A6 E0 06                       cpx #6
0E6A8 90 01                       bcc +
0E6AA                               ; string too long, abort...
0E6AA 60                            rts
0E6AB                           +
0E6AB CA                          dex
0E6AC A0 00                       ldy #0
0E6AE                           reverseLoop:
0E6AE BD 03 49                    lda ($4800 + 256)+3,x
0E6B1 29 0F                       and #%00001111
0E6B3 C9 0A                       cmp #10
0E6B5 90 01                       bcc +
0E6B7                               ; this is not a decimal character, abort...
0E6B7 60                            rts
0E6B8                           +
0E6B8 99 00 04                    sta strPort,y
0E6BB C8                          iny
0E6BC CA                          dex
0E6BD 10 EF                       bpl reverseLoop
0E6BF                           
0E6BF                             ; convert decimal to hex
0E6BF A2 00                       ldx #0
0E6C1 86 83                       stx port+0  ; MSB
0E6C3 86 84                       stx port+1  ; LSB
0E6C5                           digitLoop:
0E6C5 BD 00 04                    lda strPort,x
0E6C8 F0 18                       beq skipDigit
0E6CA A8                          tay
0E6CB                           multLoop:
0E6CB BD CD E7                    lda multiplicatorLO,x
0E6CE 18                          clc
0E6CF 65 84                       adc port+1
0E6D1 85 84                       sta port+1
0E6D3 90 02                       bcc +
0E6D5 E6 83                         inc port+0 
0E6D7                           +
0E6D7 BD C8 E7                    lda multiplicatorHI,x
0E6DA 18                          clc
0E6DB 65 83                       adc port+0
0E6DD 85 83                       sta port+0
0E6DF 88                          dey
0E6E0 D0 E9                       bne multLoop
0E6E2                           skipDigit:
0E6E2 E8                          inx
0E6E3 E4 52                       cpx textCursorPos
0E6E5 D0 DE                       bne digitLoop
0E6E7                           
0E6E7 4C EA E6                    jmp setUsernameInit
0E6EA                           
0E6EA                           
0E6EA                           
0E6EA                           setUsernameInit:
0E6EA                           
0E6EA                             ; display "enter username..." text
0E6EA A9 80                       lda #<txtUsername
0E6EC A2 E7                       ldx #>txtUsername
0E6EE 20 2F E3                    jsr set_vram_update
0E6F1 20 9D E0                    jsr waitNMI
0E6F4                           
0E6F4                             ; clear text input
0E6F4 A9 6A                       lda #<txtBlank
0E6F6 A2 ED                       ldx #>txtBlank
0E6F8 20 2F E3                    jsr set_vram_update
0E6FB 20 9D E0                    jsr waitNMI
0E6FE                           
0E6FE                             ; reset text cursor
0E6FE A2 00                       ldx #0
0E700 86 52                       stx textCursorPos
0E702                             
0E702                             ; update NT VRAM address
0E702 BD 8A ED                    lda NTaddressHI,x
0E705 8D 00 01                    sta $100
0E708 BD A6 ED                    lda NTaddressLO,x
0E70B 8D 01 01                    sta $101
0E70E                           
0E70E                             ; update chat state
0E70E A9 02                       lda #2
0E710 85 59                       sta chatState
0E712                           
0E712                             ; return
0E712 60                          rts
0E713                           
0E713                           
0E713                           
0E713                           setUsername:
0E713                           
0E713                             ; get username length
0E713 A5 52                       lda textCursorPos
0E715 D0 01                       bne +
0E717                               ; if string is empty, abort...
0E717 60                            rts
0E718                           +
0E718 C9 09                       cmp #9
0E71A 90 01                       bcc +
0E71C                               ; if string is too long, abort...
0E71C 60                            rts
0E71D                           +
0E71D 85 54                       sta usernameLength
0E71F                           
0E71F                             ; copy username string
0E71F A2 00                       ldx #0
0E721                           -
0E721 BD 03 49                    lda ($4800 + 256)+3,x
0E724 95 5A                       sta username,x
0E726 E8                          inx
0E727 E4 54                       cpx usernameLength
0E729 D0 F6                       bne -
0E72B                           
0E72B                             ; clear text
0E72B A9 A4                       lda #<txtClear
0E72D A2 E7                       ldx #>txtClear
0E72F 20 2F E3                    jsr set_vram_update
0E732 20 9D E0                    jsr waitNMI
0E735                           
0E735 4C D2 E7                    jmp chatConnect
0E738                           
0E738                           
0E738                           
0E738                           ; ################################################################################
0E738                           ; DATA
0E738                           
0E738                           txtServerHostname:
0E738 62 00 20                    .db $22|$40,$00,32
0E73B 20 20 45 6E 74 65 72 20..   .db "  Enter server IP / hostname    "
0E75B FF                          .db $FF
0E75C                           
0E75C                           txtServerPort:
0E75C 62 00 20                    .db $22|$40,$00,32
0E75F 20 20 45 6E 74 65 72 20..   .db "  Enter server port             "
0E77F FF                          .db $FF
0E780                           
0E780                           txtUsername:
0E780 62 00 20                    .db $22|$40,$00,32
0E783 20 20 45 6E 74 65 72 20..   .db "  Enter username (8 char. max)  "
0E7A3 FF                          .db $FF
0E7A4                           
0E7A4                           txtClear:
0E7A4 62 00 20                    .db $22|$40,$00,32
0E7A7 20 20 20 20 20 20 20 20..   .db "                                "
0E7C7 FF                          .db $FF
0E7C8                           
0E7C8                           multiplicatorHI:
0E7C8 00 00 00 03 27              .db >1, >10, >100, >1000, >10000
0E7CD                           
0E7CD                           multiplicatorLO:
0E7CD 01 0A 64 E8 10              .db <1, <10, <100, <1000, <100000E7D2                           .include "chat-connection.asm"
0E7D2                           ; ################################################################################
0E7D2                           ; CODE
0E7D2                           
0E7D2                           chatConnect:
0E7D2                           
0E7D2                             ; enable ESP
0E7D2 A9 01                       lda #1
0E7D4 8D 00 41                    sta $4100
0E7D7                           
0E7D7                             ; set server protocol
0E7D7 A9 02                       lda #2
0E7D9 8D 00 49                    sta ($4800 + 256)+0
0E7DC A9 15                       lda #21
0E7DE 8D 01 49                    sta ($4800 + 256)+1
0E7E1 A9 00                       lda #0
0E7E3 8D 02 49                    sta ($4800 + 256)+2
0E7E6 8D 02 41                    sta $4102
0E7E9                           
0E7E9                             ; wait for message to be sent
0E7E9                           -
0E7E9 2C 02 41                    bit $4102
0E7EC 10 FB                       bpl -
0E7EE                           
0E7EE                             ; set server host name and port
0E7EE                           .ifdef localhost
0E7EE                           
0E7EE                             SERVER_PORT EQU 8000
0E7EE                           
0E7EE A9 0C                       lda #3 + 9  ; 9 = length of 127.0.0.1
0E7F0 8D 00 49                    sta ($4800 + 256)+0
0E7F3 A9 18                       lda #24
0E7F5 8D 01 49                    sta ($4800 + 256)+1
0E7F8 A9 1F                       lda #>8000
0E7FA 8D 02 49                    sta ($4800 + 256)+2
0E7FD A9 40                       lda #<8000
0E7FF 8D 03 49                    sta ($4800 + 256)+3
0E802                           
0E802                             ; 127.0.0.1
0E802 A9 31                       lda #'1'
0E804 8D 04 49                    sta ($4800 + 256)+4
0E807 A9 32                       lda #'2'
0E809 8D 05 49                    sta ($4800 + 256)+5
0E80C A9 37                       lda #'7'
0E80E 8D 06 49                    sta ($4800 + 256)+6
0E811 A9 2E                       lda #'.'
0E813 8D 07 49                    sta ($4800 + 256)+7
0E816 A9 30                       lda #'0'
0E818 8D 08 49                    sta ($4800 + 256)+8
0E81B A9 2E                       lda #'.'
0E81D 8D 09 49                    sta ($4800 + 256)+9
0E820 A9 30                       lda #'0'
0E822 8D 0A 49                    sta ($4800 + 256)+10
0E825 A9 2E                       lda #'.'
0E827 8D 0B 49                    sta ($4800 + 256)+11
0E82A A9 31                       lda #'1'
0E82C 8D 0C 49                    sta ($4800 + 256)+12
0E82F                           
0E82F                           .else
0E82F                           
0E82F                             ; set server host name and port
0E82F                             lda #3
0E82F                             clc
0E82F                             adc hostnameLength
0E82F                             sta ($4800 + 256)+0
0E82F                            
0E82F                             lda #24
0E82F                             sta ($4800 + 256)+1
0E82F                             lda port+0
0E82F                             sta ($4800 + 256)+2
0E82F                             lda port+1
0E82F                             sta ($4800 + 256)+3
0E82F                             ldx #0
0E82F                           -
0E82F                             lda hostname,x
0E82F                             sta ($4800 + 256)+4,x
0E82F                             inx
0E82F                             cpx hostnameLength
0E82F                             bne -
0E82F                           
0E82F                           .endif
0E82F                           
0E82F                             ; send message
0E82F 8D 02 41                    sta $4102
0E832                           
0E832                             ; wait for message to be sent
0E832                           -
0E832 2C 02 41                    bit $4102
0E835 10 FB                       bpl -
0E837                           
0E837                             ; connecting to server
0E837 A9 B5                       lda #<txtConnecting
0E839 A2 E8                       ldx #>txtConnecting
0E83B 20 2F E3                    jsr set_vram_update
0E83E 20 9D E0                    jsr waitNMI
0E841                           
0E841                             ; connect to server
0E841                           connectToServer:
0E841                           
0E841                             ; send command
0E841 A9 01                       lda #1
0E843 8D 00 49                    sta ($4800 + 256)+0
0E846 A9 1A                       lda #26
0E848 8D 01 49                    sta ($4800 + 256)+1
0E84B 8D 02 41                    sta $4102
0E84E                           
0E84E                             ; wait for message to be sent
0E84E                           -
0E84E 2C 02 41                    bit $4102
0E851 10 FB                       bpl -
0E853                           
0E853                             ; let's ask for server status every 2 seconds
0E853                             ; if we're still not connected after 20 seconds
0E853                             ; then try to connect again...
0E853                           checkServerStatus:
0E853 A0 0A                       ldy #10
0E855                           wait2seconds:
0E855 A2 78                       ldx #120
0E857                           -
0E857 20 9D E0                    jsr waitNMI
0E85A CA                          dex
0E85B D0 FA                       bne -
0E85D                           
0E85D                             ; check server status
0E85D A9 01                       lda #1
0E85F 8D 00 49                    sta ($4800 + 256)+0
0E862 A9 13                       lda #19
0E864 8D 01 49                    sta ($4800 + 256)+1
0E867 8D 02 41                    sta $4102
0E86A                           
0E86A                             ; wait for message to be sent
0E86A                           -
0E86A 2C 02 41                    bit $4102
0E86D 10 FB                       bpl -
0E86F                             
0E86F                             ; wait for answer
0E86F                           -
0E86F 2C 01 41                    bit $4101
0E872 10 FB                       bpl -
0E874                           
0E874                             ; get data
0E874                             ; ignore message length and opcode/command
0E874 AD 02 48                    lda $4800+2 ; server status
0E877 8D 01 41                    sta $4101  ; acknowledge answer
0E87A C9 01                       cmp #1
0E87C F0 06                       beq connected
0E87E                           
0E87E 88                          dey
0E87F D0 D4                       bne wait2seconds
0E881 4C 41 E8                    jmp connectToServer
0E884                           
0E884                           connected:
0E884                           
0E884                             ; register username
0E884 A9 02                       lda #2
0E886 18                          clc
0E887 65 54                       adc usernameLength
0E889 8D 00 49                    sta ($4800 + 256)+0
0E88C A9 1C                       lda #28
0E88E 8D 01 49                    sta ($4800 + 256)+1
0E891 A2 00                       ldx #0
0E893 8E 02 49                    stx ($4800 + 256)+2
0E896                           -
0E896 B5 5A                       lda username,x
0E898 9D 03 49                    sta ($4800 + 256)+3,x
0E89B E8                          inx
0E89C E4 54                       cpx usernameLength
0E89E D0 F6                       bne -
0E8A0 8D 02 41                    sta $4102
0E8A3                             ; wait for message to be sent
0E8A3                           -
0E8A3 2C 02 41                    bit $4102
0E8A6 10 FB                       bpl -
0E8A8                           
0E8A8                           
0E8A8                             ; connected to server
0E8A8                           ;  lda #<txtConnected
0E8A8                           ;  ldx #>txtConnected
0E8A8                           ;  jsr set_vram_update
0E8A8                           ;:
0E8A8                           ;  jsr waitNMI
0E8A8                           
0E8A8                             ; wait for user to press a button before clearing the message
0E8A8                           ;  ldy #0
0E8A8                           ;  jsr pad::read
0E8A8                           ;  lda pad::pressed
0E8A8                           ;  and #PAD_START
0E8A8                           ;  beq :-
0E8A8                           
0E8A8                             ; clear text
0E8A8 A9 6A                       lda #<txtBlank
0E8AA A2 ED                       ldx #>txtBlank
0E8AC 20 2F E3                    jsr set_vram_update
0E8AF 20 9D E0                    jsr waitNMI
0E8B2                           
0E8B2 4C 40 EA                    jmp chatInit
0E8B5                           
0E8B5                           
0E8B5                           ; ################################################################################
0E8B5                           ; DATA
0E8B5                           
0E8B5                           txtConnecting:
0E8B5 62 62 1C                    .db $22|$40,$62,28
0E8B8 43 4F 4E 4E 45 43 54 49..   .db "CONNECTING...               "
0E8D4 FF                          .db $ff
0E8D5                           
0E8D5                           ;txtConnected:
0E8D5                           ;  .db $22|NT_UPD_HORZ,$62,28
0E8D5                           ;  .db "CONNECTED...   (press START)"
0E8D5                           ;  .db $ff
0E8D5                           .include "chat-message-handler.asm"
0E8D5                           ; ################################################################################
0E8D5                           ; CODE
0E8D5                           
0E8D5                           newUser:
0E8D5                           
0E8D5                             ; prepare the NT update buffer
0E8D5 A5 57                       lda NTaddress+0
0E8D7 09 40                       ora #$40
0E8D9 8D 10 01                    sta $110
0E8DC A5 58                       lda NTaddress+1
0E8DE 8D 11 01                    sta $111
0E8E1                           
0E8E1 A9 53                       lda #'S'
0E8E3 8D 13 01                    sta $113
0E8E6 A9 45                       lda #'E'
0E8E8 8D 14 01                    sta $114
0E8EB A9 52                       lda #'R'
0E8ED 8D 15 01                    sta $115
0E8F0 A9 56                       lda #'V'
0E8F2 8D 16 01                    sta $116
0E8F5 A9 45                       lda #'E'
0E8F7 8D 17 01                    sta $117
0E8FA A9 52                       lda #'R'
0E8FC 8D 18 01                    sta $118
0E8FF A9 3A                       lda #$3A ;':'
0E901 8D 19 01                    sta $119
0E904                           
0E904                             ; fill NT buffer with blank tile
0E904 A9 00                       lda #0
0E906 A2 00                       ldx #0
0E908                           -
0E908 9D 1A 01                    sta $11a,x
0E90B E8                          inx
0E90C E0 15                       cpx #21
0E90E D0 F8                       bne -
0E910                           
0E910                             ; update VRAM
0E910 A9 10                       lda #<$110
0E912 A2 01                       ldx #>$110
0E914 20 2F E3                    jsr set_vram_update
0E917 20 9D E0                    jsr waitNMI
0E91A                           
0E91A                             ; update NT VRAM address
0E91A A9 20                       lda #$20
0E91C 20 F1 E9                    jsr updateChatNTaddress
0E91F                           
0E91F                             ; prepare the NT update buffer
0E91F A5 57                       lda NTaddress+0
0E921 09 40                       ora #$40
0E923 8D 10 01                    sta $110
0E926 A5 58                       lda NTaddress+1
0E928 8D 11 01                    sta $111
0E92B                           
0E92B                             ; indent by adding a blank tile
0E92B A9 00                       lda #0
0E92D 8D 13 01                    sta $113
0E930                           
0E930                             ; calculate message length
0E930 AD 00 48                    lda $4800+0  ; get data length
0E933 38                          sec
0E934 E9 02                       sbc #2
0E936 85 55                       sta messageLength
0E938                           
0E938                             ; copy message to NT update buffer
0E938 A8                          tay
0E939 A2 00                       ldx #0
0E93B                           -
0E93B BD 03 48                    lda $4800+3,x
0E93E 9D 14 01                    sta $114,x
0E941 E8                          inx
0E942 88                          dey
0E943 D0 F6                       bne -
0E945                           
0E945                             ; don't need to fill with blank tiles here since we cleared it just before
0E945                           
0E945                             ; update VRAM
0E945 A9 10                       lda #<$110
0E947 A2 01                       ldx #>$110
0E949 20 2F E3                    jsr set_vram_update
0E94C 20 9D E0                    jsr waitNMI
0E94F                           
0E94F                             ; update NT VRAM address
0E94F A9 40                       lda #$40
0E951 20 F1 E9                    jsr updateChatNTaddress
0E954                           
0E954 8D 01 41                    sta $4101  ; acknowledge received message
0E957                           
0E957                             ; return
0E957 60                          rts
0E958                           
0E958                           
0E958                           
0E958                           newMessage:
0E958                           
0E958                             ; find separator between username and actual message
0E958                             ; let's start from 1 because username can't be empty
0E958 A2 01                       ldx #1
0E95A                           -
0E95A BD 03 48                    lda $4800+3,x ; +3 because we're ignoring data length and opcodes (2)
0E95D F0 04                       beq +
0E95F E8                          inx
0E960 4C 5A E9                    jmp -
0E963                           
0E963                           +
0E963 86 53                       stx separatorPos
0E965 86 54                       stx usernameLength
0E967                           
0E967                             ; calculate message end index and message length
0E967 AD 00 48                    lda $4800+0  ; get data length
0E96A 38                          sec
0E96B E9 03                       sbc #3              ; substract 3 (data length + 2 opcodes)
0E96D 85 56                       sta messageEnd
0E96F E6 56                       inc messageEnd      ; increment because of zero-indexing
0E971 E5 54                       sbc usernameLength
0E973 85 55                       sta messageLength
0E975                           
0E975                             ; display username first
0E975                           
0E975                             ; prepare the NT update buffer
0E975 A5 57                       lda NTaddress+0
0E977 09 40                       ora #$40
0E979 8D 10 01                    sta $110
0E97C A5 58                       lda NTaddress+1
0E97E 8D 11 01                    sta $111
0E981                           
0E981                             ; copy username to NT update buffer
0E981 A4 54                       ldy usernameLength
0E983 A2 00                       ldx #0
0E985                           -
0E985 BD 03 48                    lda $4800+3,x
0E988 9D 13 01                    sta $113,x
0E98B E8                          inx
0E98C 88                          dey
0E98D D0 F6                       bne -
0E98F                           
0E98F                             ; add colon
0E98F A9 3A                       lda #$3A ;':'
0E991 9D 13 01                    sta $113,x
0E994 E8                          inx
0E995                           
0E995                             ; fill with empty tile
0E995 A9 00                       lda #0
0E997                           -
0E997 9D 13 01                    sta $113,x
0E99A E8                          inx
0E99B E0 1D                       cpx #29
0E99D D0 F8                       bne -
0E99F                           
0E99F                             ; update VRAM
0E99F A9 10                       lda #<$110
0E9A1 A2 01                       ldx #>$110
0E9A3 20 2F E3                    jsr set_vram_update
0E9A6 20 9D E0                    jsr waitNMI
0E9A9                           
0E9A9                             ; update NT VRAM address
0E9A9 A9 20                       lda #$20
0E9AB 20 F1 E9                    jsr updateChatNTaddress
0E9AE                           
0E9AE                             ; display message
0E9AE                           
0E9AE                             ; prepare the NT update buffer
0E9AE A5 57                       lda NTaddress+0
0E9B0 09 40                       ora #$40
0E9B2 8D 10 01                    sta $110
0E9B5 A5 58                       lda NTaddress+1
0E9B7 8D 11 01                    sta $111
0E9BA                           
0E9BA                             ; indent by adding a blank tile
0E9BA A9 00                       lda #0
0E9BC 8D 13 01                    sta $113
0E9BF                           
0E9BF                             ; copy message to NT update buffer
0E9BF A0 00                       ldy #0
0E9C1 A6 53                       ldx separatorPos
0E9C3 E8                          inx
0E9C4                           -
0E9C4 BD 03 48                    lda $4800+3,x
0E9C7 99 14 01                    sta $114,y
0E9CA C8                          iny
0E9CB E8                          inx
0E9CC E4 56                       cpx messageEnd
0E9CE D0 F4                       bne -
0E9D0                           
0E9D0 C0 1C                       cpy #28
0E9D2 F0 0A                       beq skipFillingMessage
0E9D4                           
0E9D4                             ; fill with empty tile
0E9D4 A9 00                       lda #0
0E9D6                           -
0E9D6 99 14 01                    sta $114,y
0E9D9 C8                          iny
0E9DA C0 1C                       cpy #28
0E9DC D0 F8                       bne -
0E9DE                           
0E9DE                           skipFillingMessage:
0E9DE                           
0E9DE                             ; update VRAM
0E9DE A9 10                       lda #<$110
0E9E0 A2 01                       ldx #>$110
0E9E2 20 2F E3                    jsr set_vram_update
0E9E5 20 9D E0                    jsr waitNMI
0E9E8                           
0E9E8                             ; update NT VRAM address
0E9E8 A9 40                       lda #$40
0E9EA 20 F1 E9                    jsr updateChatNTaddress
0E9ED                           
0E9ED 8D 01 41                    sta $4101  ; acknowledge received message
0E9F0                           
0E9F0                             ; return
0E9F0 60                          rts
0E9F1                           
0E9F1                           
0E9F1                           updateChatNTaddress:
0E9F1                             ; A = increment value
0E9F1                           
0E9F1                             ; update address
0E9F1 18                          clc
0E9F2 65 58                       adc NTaddress+1
0E9F4 85 58                       sta NTaddress+1
0E9F6 90 02                       bcc +
0E9F8 E6 57                         inc NTaddress+0
0E9FA                           +
0E9FA                           
0E9FA                             ; check if we need to wrap
0E9FA A5 57                       lda NTaddress+0
0E9FC C9 22                       cmp #$22
0E9FE D0 08                       bne +
0EA00                           
0EA00                               ; reset NT VRAM address
0EA00 A9 20                         lda #$20
0EA02 85 57                         sta NTaddress+0
0EA04 A9 41                         lda #$41
0EA06 85 58                         sta NTaddress+1
0EA08                           
0EA08                           +
0EA08                             ; return
0EA08 60                          rts
0EA09                           
0EA09                           
0EA09                           
0EA09                           
0EA09                           ;clearLine:
0EA09                           ;  ; A = MSB NT address
0EA09                           ;  ; X = LSB NT address
0EA09                           ;  ora #NT_UPD_HORZ
0EA09                           ;  sta $110
0EA09                           ;  stx $111
0EA09                           ;  ldx #0
0EA09                           ;  lda #0
0EA09                           ;:
0EA09                           ;  sta $113,x
0EA09                           ;  inx
0EA09                           ;  cpx #TEXT_MAX_LENGTH
0EA09                           ;  bne :-
0EA09                           ;
0EA09                           ;  lda #NT_UPD_EOF
0EA09                           ;  sta $113,x
0EA09                           ;
0EA09                           ;  ; update VRAM
0EA09                           ;  lda #<$110
0EA09                           ;  ldx #>$110
0EA09                           ;  jsr set_vram_update
0EA09                           ;  jsr waitNMI
0EA09                           ;
0EA09                           ;  ; return
0EA09                           ;  rts
0EA09                           
0EA09                           ; ################################################################################
0EA09                           ; CODE
0EA09                           
0EA09                           startChat:
0EA09                           
0EA09 20 12 EA                    jsr chatInitView
0EA0C                           .ifdef localhost
0EA0C 20 EA E6                    jsr setUsernameInit
0EA0F                           .else
0EA0F                             jsr setHostnameInit
0EA0F                           .endif
0EA0F 4C 69 EA                    jmp chatLoop
0EA12                           
0EA12                           
0EA12                           
0EA12                           chatInitView:
0EA12                           
0EA12                             ; cursor tile
0EA12 A9 1E                       lda #$1e
0EA14 8D 01 02                    sta $0200+1
0EA17                             
0EA17                             ; cursor attribute
0EA17 A9 02                       lda #2
0EA19 8D 02 02                    sta $0200+2
0EA1C                           
0EA1C                             ; prepare text field NT update
0EA1C A9 22                       lda #$22
0EA1E 8D 00 01                    sta $100
0EA21 A9 62                       lda #$62
0EA23 8D 01 01                    sta $101
0EA26 A9 FF                       lda #$FF
0EA28 8D 03 01                    sta $103
0EA2B                           
0EA2B                             ; set VRAM address
0EA2B A9 20                       lda #$20
0EA2D 8D 06 20                    sta $2006
0EA30 A9 00                       lda #$00
0EA32 8D 06 20                    sta $2006
0EA35                           
0EA35                             ; load NT data
0EA35 A2 EB                       ldx #>chatNT
0EA37 A9 F3                       lda #<chatNT
0EA39 20 93 E3                    jsr vram_unrle
0EA3C                           
0EA3C                             ; enable rendering
0EA3C 20 36 E0                    jsr ppu_on_all
0EA3F                           
0EA3F                             ; return
0EA3F 60                          rts
0EA40                           
0EA40                           
0EA40                           
0EA40                           chatInit:
0EA40                           
0EA40                             ; init vars
0EA40 A9 00                       lda #0
0EA42 85 50                       sta cursorPos
0EA44 85 51                       sta cursorHoldCnt
0EA46 85 52                       sta textCursorPos
0EA48                            
0EA48                             ; init NT VRAM address
0EA48 A9 20                       lda #$20
0EA4A 85 57                       sta NTaddress+0
0EA4C A9 41                       lda #$41
0EA4E 85 58                       sta NTaddress+1
0EA50                           
0EA50                             ; we will always push 29 characters
0EA50                             ; (28 message max + 1 for message indent)
0EA50                             ; $112 is the NT buffer data length
0EA50                             ; see ppu.s, proc flush_vram_update_nmi (line 693) for details
0EA50 A9 1D                       lda #29
0EA52 8D 12 01                    sta $112
0EA55                             ; end the EOF opcode will always be at the same place too
0EA55 A9 FF                       lda #$FF
0EA57 8D 30 01                    sta $130
0EA5A                           
0EA5A                             ; init Rainbow output buffer
0EA5A                             ; message format is:
0EA5A                             ; length | TOESP_SERVER_SEND_MSG | 0x01 (new msg opcode) | message / string ...
0EA5A                             ;lda #2
0EA5A                             ;sta RNBW_BUF_OUT+0    ; no need to set the length yet
0EA5A A9 1C                       lda #28
0EA5C 8D 01 49                    sta ($4800 + 256)+1
0EA5F A9 01                       lda #1
0EA61 8D 02 49                    sta ($4800 + 256)+2
0EA64                           
0EA64                             ; update chat state
0EA64 A9 03                       lda #3
0EA66 85 59                       sta chatState
0EA68                           
0EA68                             ; return
0EA68 60                          rts
0EA69                           
0EA69                           
0EA69                           
0EA69                           chatLoop:
0EA69                           
0EA69                             ; check for incomming data from ESP
0EA69 2C 01 41                    bit $4101
0EA6C 10 03                       bpl +
0EA6E 20 D3 EB                      jsr processData
0EA71                           +
0EA71                           
0EA71                             ; poll controller
0EA71 A0 00                       ldy #0
0EA73 20 E3 E4                    jsr padRead
0EA76                           
0EA76                             ; handle long press on LEFT / RIGHT / A
0EA76                           
0EA76 A5 3F                       lda padState
0EA78 29 40                       and #$40
0EA7A F0 10                       beq skipLEFTstate
0EA7C A5 51                         lda cursorHoldCnt
0EA7E C9 1E                         cmp #30
0EA80 D0 05                         bne +
0EA82 C6 51                           dec cursorHoldCnt
0EA84 4C C5 EA                        jmp decCursor
0EA87                             +
0EA87 E6 51                         inc cursorHoldCnt
0EA89 4C A2 EA                      jmp skipRIGHTstate
0EA8C                           skipLEFTstate:
0EA8C                           
0EA8C A5 3F                       lda padState
0EA8E 29 80                       and #$80
0EA90 F0 10                       beq skipRIGHTstate
0EA92 A5 51                         lda cursorHoldCnt
0EA94 C9 1E                         cmp #30
0EA96 D0 05                         bne +
0EA98 C6 51                           dec cursorHoldCnt
0EA9A 4C D1 EA                        jmp incCursor
0EA9D                             +
0EA9D E6 51                         inc cursorHoldCnt
0EA9F 4C A2 EA                      jmp skipRIGHTstate
0EAA2                           skipRIGHTstate:
0EAA2                           
0EAA2 A5 3F                       lda padState
0EAA4 29 01                       and #$01
0EAA6 F0 0D                       beq skipAstate
0EAA8 A5 51                         lda cursorHoldCnt
0EAAA C9 1E                         cmp #30
0EAAC D0 05                         bne +
0EAAE C6 51                           dec cursorHoldCnt
0EAB0 4C FF EA                        jmp removeChar
0EAB3                             +
0EAB3 E6 51                         inc cursorHoldCnt
0EAB5                           skipAstate:
0EAB5                           
0EAB5                             ; handle long press release for RIGHT / LEFT / A
0EAB5                           
0EAB5 A5 41                       lda padReleased
0EAB7 29 C1                       and #$80|$40|$01
0EAB9 F0 04                       beq skipLEFT_RIGHT_Areleased
0EABB A9 00                         lda #0
0EABD 85 51                         sta cursorHoldCnt
0EABF                           skipLEFT_RIGHT_Areleased:
0EABF                           
0EABF                             ; handle pressed button
0EABF                           
0EABF A5 40                       lda padPressed
0EAC1 29 40                       and #$40
0EAC3 F0 06                       beq skipLEFTpressed
0EAC5                           decCursor:
0EAC5                               ; decrement cursor position by one (1) if possible
0EAC5 A5 50                         lda cursorPos
0EAC7 F0 02                         beq skipLEFTpressed
0EAC9 C6 50                         dec cursorPos
0EACB                           skipLEFTpressed:
0EACB                           
0EACB A5 40                       lda padPressed
0EACD 29 80                       and #$80
0EACF F0 08                       beq skipRIGHTpressed
0EAD1                           incCursor:
0EAD1                               ; increment cursor position by one (1) if possible
0EAD1 A5 50                         lda cursorPos
0EAD3 C9 59                         cmp #90-1
0EAD5 F0 02                         beq skipRIGHTpressed
0EAD7 E6 50                         inc cursorPos
0EAD9                           skipRIGHTpressed:
0EAD9                           
0EAD9 A5 40                       lda padPressed
0EADB 29 10                       and #$10
0EADD F0 09                       beq skipUPpressed
0EADF                               ; move cursor position to previous line if possible
0EADF A5 50                         lda cursorPos
0EAE1 38                            sec
0EAE2 E9 1E                         sbc #30
0EAE4 90 02                         bcc skipUPpressed
0EAE6 85 50                         sta cursorPos
0EAE8                           skipUPpressed:
0EAE8                           
0EAE8 A5 40                       lda padPressed
0EAEA 29 20                       and #$20
0EAEC F0 0B                       beq skipDOWNpressed
0EAEE                               ; move cursor position to next line if possible
0EAEE A5 50                         lda cursorPos
0EAF0 18                            clc
0EAF1 69 1E                         adc #30
0EAF3 C9 5A                         cmp #90
0EAF5 B0 02                         bcs skipDOWNpressed
0EAF7 85 50                         sta cursorPos
0EAF9                           skipDOWNpressed:
0EAF9                           
0EAF9 A5 40                       lda padPressed
0EAFB 29 01                       and #$01
0EAFD F0 03                       beq skipApressed
0EAFF                           removeChar:
0EAFF                               ; remove last character from text input
0EAFF 20 84 EB                      jsr removeCharacter
0EB02                           skipApressed:
0EB02                           
0EB02 A5 40                       lda padPressed
0EB04 29 02                       and #$02
0EB06 F0 08                       beq skipBpressed
0EB08                               ; add a new character to text input
0EB08 A5 50                         lda cursorPos
0EB0A 18                            clc
0EB0B 69 21                         adc #$21
0EB0D 20 5C EB                      jsr addCharacter
0EB10                           skipBpressed:
0EB10                           
0EB10 A5 40                       lda padPressed
0EB12 29 04                       and #$04
0EB14 F0 05                       beq skipSELECTpressed
0EB16                               ; add SPACE to text input
0EB16 A9 20                         lda #$20
0EB18 20 5C EB                      jsr addCharacter
0EB1B                           skipSELECTpressed:
0EB1B                           
0EB1B A5 40                       lda padPressed
0EB1D 29 08                       and #$08
0EB1F F0 23                       beq skipSTARTpressed
0EB21                               ; branch on chat state
0EB21 A5 59                         lda chatState
0EB23 C9 00                         cmp #0
0EB25 D0 06                         bne +
0EB27 20 62 E6                        jsr setHostname
0EB2A 4C 44 EB                        jmp skipSTARTpressed
0EB2D                             +
0EB2D C9 01                         cmp #1
0EB2F D0 06                         bne +
0EB31 20 A1 E6                        jsr setPort
0EB34 4C 44 EB                        jmp skipSTARTpressed
0EB37                             +
0EB37 C9 02                         cmp #2
0EB39 D0 06                         bne +
0EB3B 20 13 E7                        jsr setUsername
0EB3E 4C 44 EB                        jmp skipSTARTpressed
0EB41                             +
0EB41                               ; send message
0EB41 20 AE EB                      jsr sendMessage
0EB44                           skipSTARTpressed:
0EB44                           
0EB44                             ; update cursor on screen
0EB44 20 4D EB                    jsr updateCursor
0EB47                           
0EB47                             ; wait for NMI
0EB47 20 9D E0                    jsr waitNMI
0EB4A                           
0EB4A                             ; and loop...
0EB4A 4C 69 EA                    jmp chatLoop
0EB4D                           
0EB4D                           
0EB4D                           
0EB4D                           updateCursor:
0EB4D                           
0EB4D A6 50                       ldx cursorPos
0EB4F BD B6 EC                    lda cursorPosX,x
0EB52 8D 03 02                    sta $0200+3
0EB55 BD 10 ED                    lda cursorPosY,x
0EB58 8D 00 02                    sta $0200+0
0EB5B                           
0EB5B                             ; return
0EB5B 60                          rts
0EB5C                           
0EB5C                           
0EB5C                           
0EB5C                           addCharacter:
0EB5C                           
0EB5C                             ; Rainbow output buffer with new character
0EB5C 8D 02 01                    sta $102
0EB5F A6 52                       ldx textCursorPos
0EB61 9D 03 49                    sta ($4800 + 256)+3,x
0EB64                             
0EB64                             ; update NT VRAM address
0EB64 BD 8A ED                    lda NTaddressHI,x
0EB67 8D 00 01                    sta $100
0EB6A BD A6 ED                    lda NTaddressLO,x
0EB6D 8D 01 01                    sta $101
0EB70                           
0EB70                             ; are we at the limit ?
0EB70 A5 52                       lda textCursorPos
0EB72 C9 1C                       cmp #28
0EB74 D0 01                       bne +
0EB76                               ; return
0EB76 60                            rts
0EB77                           +
0EB77                           
0EB77                             ; update VRAM
0EB77 A9 00                       lda #<$100
0EB79 A2 01                       ldx #>$100
0EB7B 20 2F E3                    jsr set_vram_update
0EB7E 20 9D E0                    jsr waitNMI
0EB81                           
0EB81                             ; increment text index pos
0EB81 E6 52                       inc textCursorPos
0EB83                           
0EB83                             ; return
0EB83 60                          rts
0EB84                           
0EB84                           
0EB84                           removeCharacter:
0EB84                           
0EB84                             ; are we at the begining of the line ?
0EB84 A5 52                       lda textCursorPos
0EB86 D0 01                       bne +
0EB88                               ; return
0EB88 60                            rts
0EB89                           +
0EB89                           
0EB89                             ; update NT and Rainbow output buffer with new character
0EB89 A9 20                       lda #$20
0EB8B 8D 02 01                    sta $102
0EB8E                           
0EB8E A6 52                       ldx textCursorPos
0EB90 9D 03 49                    sta ($4800 + 256)+3,x
0EB93                           
0EB93                             ; decrement text index pos
0EB93 C6 52                       dec textCursorPos
0EB95                           
0EB95                             ; update NT VRAM address
0EB95 A6 52                       ldx textCursorPos
0EB97 BD 8A ED                    lda NTaddressHI,x
0EB9A 8D 00 01                    sta $100
0EB9D BD A6 ED                    lda NTaddressLO,x
0EBA0 8D 01 01                    sta $101
0EBA3                           
0EBA3                             ; set VRAM update pointer
0EBA3 A9 00                       lda #<$100
0EBA5 A2 01                       ldx #>$100
0EBA7 20 2F E3                    jsr set_vram_update
0EBAA 20 9D E0                    jsr waitNMI
0EBAD                           
0EBAD                             ; return
0EBAD 60                          rts
0EBAE                           
0EBAE                           
0EBAE                           
0EBAE                           sendMessage:
0EBAE                           
0EBAE                             ; are we at the begining of the line ?
0EBAE A5 52                       lda textCursorPos
0EBB0 D0 01                       bne +
0EBB2                               ; return
0EBB2 60                            rts
0EBB3                           +
0EBB3                           
0EBB3                             ; update message length
0EBB3 A9 02                       lda #2
0EBB5 18                          clc
0EBB6 65 52                       adc textCursorPos
0EBB8 8D 00 49                    sta ($4800 + 256)+0
0EBBB                           
0EBBB                             ; send data using the Rainbow output buffer
0EBBB A9 00                       lda #<($4800 + 256)
0EBBD A2 49                       ldx #>($4800 + 256)
0EBBF 20 2C E5                    jsr RNBW_sendData
0EBC2                           
0EBC2                             ; clear text input
0EBC2 A9 6A                       lda #<txtBlank
0EBC4 A2 ED                       ldx #>txtBlank
0EBC6 20 2F E3                    jsr set_vram_update
0EBC9                           
0EBC9                             ; reset text cursor
0EBC9 A9 00                       lda #0
0EBCB 85 52                       sta textCursorPos
0EBCD                           
0EBCD                             ; reset NT address
0EBCD A9 62                       lda #$62
0EBCF 8D 01 01                    sta $101
0EBD2                           
0EBD2                             ; return
0EBD2 60                          rts
0EBD3                           
0EBD3                           
0EBD3                           
0EBD3                           processData:
0EBD3                             ; data available in RAM buffer (RNBW_BUF_IN)
0EBD3                           
0EBD3                             ; is it a message from server ?
0EBD3 AD 01 48                    lda $4800+1
0EBD6 C9 0C                       cmp #12
0EBD8 F0 04                       beq +
0EBDA                               ; if not, ignore the message for now...
0EBDA                               ; TODO...
0EBDA                           
0EBDA 8D 01 41                      sta $4101  ; acknowledge received message
0EBDD                           
0EBDD                               ; return
0EBDD 60                            rts
0EBDE                           +
0EBDE                           
0EBDE                             ; branch on server opcode
0EBDE AD 02 48                    lda $4800+2
0EBE1 C9 00                       cmp #0
0EBE3 D0 03                       bne +
0EBE5 4C D5 E8                      jmp newUser
0EBE8                           +
0EBE8 C9 01                       cmp #1
0EBEA D0 03                       bne +
0EBEC 4C 58 E9                      jmp newMessage
0EBEF                           +
0EBEF                             ; unknown opcode, don't do anything...
0EBEF                             ; TODO...
0EBEF                           
0EBEF 8D 01 41                    sta $4101  ; acknowledge received message
0EBF2                           
0EBF2                             ; return
0EBF2 60                          rts
0EBF3                           
0EBF3                           
0EBF3                           
0EBF3                           ; ################################################################################
0EBF3                           ; DATA
0EBF3                           
0EBF3                           chatNT:
0EBF3 01 00 01 FE 00 01 FE 00..   .incbin "gfx/chat.rle"
0EC96                           
0EC96                           chatPAL:
0EC96 0C 00 10 30 0C 00 10 0C..   .db $0c,$00,$10,$30,$0c,$00,$10,$0c,$0c,$17,$27,$37,$0c,$00,$19,$29
0ECA6 0C 00 10 30 0C 00 10 0C..   .db $0c,$00,$10,$30,$0c,$00,$10,$0c,$0c,$17,$27,$37,$0c,$00,$19,$29
0ECB6                           
0ECB6                           cursorPosX:
0ECB6                             I=0
0ECB6                             .rept 3
0ECB6                               .rept 30
0ECB6                                 .db 8*(I+1)
0ECB6                                 I=I+1
0ECB6                               .endr
0ECB6                               I=0
0ECB6 08 10 18 20 28 30 38 40..   .endr
0ED10                           
0ED10                           cursorPosY:
0ED10                             .rept 30
0ED10                               .db 184
0ED10 B8 B8 B8 B8 B8 B8 B8 B8..   .endr
0ED2E                             .rept 30
0ED2E                               .db 200
0ED2E C8 C8 C8 C8 C8 C8 C8 C8..   .endr
0ED4C                             .rept 30
0ED4C                               .db 216
0ED4C D8 D8 D8 D8 D8 D8 D8 D8..   .endr
0ED6A                           
0ED6A                           txtBlank:
0ED6A 62 62 1C                    .db $22|$40,$62,28
0ED6D 20 20 20 20 20 20 20 20..   .db "                            "
0ED89 FF                          .db $FF
0ED8A                           
0ED8A                           NTaddressHI:
0ED8A                           I=0
0ED8A                           .rept 28
0ED8A                             .db >($2262+I)
0ED8A                             I=I+1
0ED8A 22 22 22 22 22 22 22 22.. .endr
0EDA6                           
0EDA6                           NTaddressLO:
0EDA6                           I=0
0EDA6                           .rept 28
0EDA6                             .db <($2262+I)
0EDA6                             I=I+1
0EDA6 62 63 64 65 66 67 68 69.. .endr
0EDC2                           
0EDC2                           ; ################################################################################
0EDC2                           ; CONSTANTS
0EDC2                           
0EDC2                           ; ################################################################################
0EDC2                           ; CODE
0EDC2                           
0EDC2                             vector_reset:
0EDC2                           
0EDC2 D8                          cld
0EDC3 78                          sei
0EDC4 A2 FF                       ldx #$FF
0EDC6 9A                          txs
0EDC7                           
0EDC7                           initPPU1:
0EDC7 AD 02 20                    lda $2002
0EDCA 10 FB                       bpl initPPU1
0EDCC                           initPPU2:
0EDCC AD 02 20                    lda $2002
0EDCF 10 FB                       bpl initPPU2
0EDD1                           
0EDD1 A2 00                       ldx #$00
0EDD3 8E 01 20                    stx $2001
0EDD6 8E 10 40                    stx $4010
0EDD9 8E 00 20                    stx $2000        ;no NMI
0EDDC                           
0EDDC                           clearRAM:
0EDDC 8A                          txa
0EDDD                           -
0EDDD 95 00                       sta $000,x
0EDDF 9D 00 01                    sta $100,x
0EDE2 9D 00 02                    sta $200,x
0EDE5 9D 00 03                    sta $300,x
0EDE8 9D 00 04                    sta $400,x
0EDEB 9D 00 05                    sta $500,x
0EDEE 9D 00 06                    sta $600,x
0EDF1 9D 00 07                    sta $700,x
0EDF4 E8                          inx
0EDF5 D0 E6                       bne -
0EDF7                           
0EDF7 20 3F E0                    jsr oam_clear
0EDFA                           
0EDFA A9 80                       lda #%10000000
0EDFC 85 22                       sta <PPU_CTRL_VAR
0EDFE 8D 00 20                    sta $2000        ; enable NMI
0EE01 A9 06                       lda #%00000110
0EE03 85 23                       sta <PPU_MASK_VAR
0EE05                           
0EE05                           waitSync3:
0EE05 A5 20                       lda FRAME_CNT1
0EE07                           -
0EE07 C5 20                       cmp FRAME_CNT1
0EE09 F0 FC                       beq -
0EE0B                           
0EE0B                             ; get TV system
0EE0B                             ; 0 : NTSC
0EE0B                             ; 1 : PAL
0EE0B                             ; 2 : dendy
0EE0B                             ; 3 : unknown
0EE0B 20 00 E0                    jsr getTVSystem
0EE0E                           
0EE0E                             ; initialize sound APU
0EE0E A2 00                       ldx #$00
0EE10                           apu_clear_loop:
0EE10 9D 00 40                    sta $4000, X            ; write 0 to most APU registers
0EE13 E8                          inx
0EE14 E0 13                       cpx #$13
0EE16 D0 F8                       bne apu_clear_loop
0EE18 A2 00                       ldx #$00
0EE1A 8E 15 40                    stx $4015               ; turn off square/noise/triangle/DPCM channels
0EE1D                           
0EE1D                             ; acknowledge/disable both APU IRQs
0EE1D                             ; (frame counter and DMC completion)
0EE1D A9 40                       lda #$40
0EE1F 8D 17 40                    sta $4017  ; APU IRQ: OFF!
0EE22 AD 15 40                    lda $4015  ; APU IRQ: ACK!
0EE25                           
0EE25                             ; disable ESP for now
0EE25 A9 00                       lda #0
0EE27 8D 00 41                    sta MAP_RNBW_CONFIG
0EE2A                           
0EE2A                             ; init Rainbow RX/TX RAM addresses
0EE2A A9 48                       lda #>$4800
0EE2C 8D 03 41                    sta $4103
0EE2F A9 49                       lda #>($4800 + 256)
0EE31 8D 04 41                    sta $4104
0EE34                           
0EE34                             ; mapper init
0EE34 A9 1C                       lda #%00011100
0EE36 8D 10 41                    sta MAP_CONFIG
0EE39                           
0EE39                             ; select 8K CHR bank
0EE39 A9 00                       lda #0
0EE3B 8D 30 41                    sta MAP_CHR_0
0EE3E                           
0EE3E                             ; set palette brightness
0EE3E A9 04                       lda #4
0EE40 85 2A                       sta palBrightness
0EE42 20 A4 E0                    jsr setPaletteBrightness
0EE45                           
0EE45                             ; set palette fade delay
0EE45 A9 02                       lda #2
0EE47 85 2C                       sta palFadeDelay
0EE49                           
0EE49                             ; load palette
0EE49 A2 EC                       ldx #>chatPAL
0EE4B A9 96                       lda #<chatPAL
0EE4D 20 08 E2                    jsr pal_all
0EE50                           
0EE50                             ; push palette updates
0EE50 20 27 E2                    jsr flushPalette
0EE53                           
0EE53                             ; set BG CHR page
0EE53 A9 00                       lda #0
0EE55 20 E3 E1                    jsr setBG_bank
0EE58                           
0EE58                             ; set SPR CHR page
0EE58 A9 00                       lda #0
0EE5A 20 D3 E1                    jsr setSPR_bank
0EE5D                           
0EE5D                             ; enable all channels but DPCM
0EE5D                             ;lda #$0F
0EE5D                             ;sta $4015
0EE5D                           
0EE5D                             ; set VRAM address
0EE5D A9 00                       lda #$00
0EE5F 8D 06 20                    sta $2006
0EE62 A9 00                       lda #$00
0EE64 8D 06 20                    sta $2006
0EE67                           
0EE67                             ; load CHR data
0EE67 A2 EE                       ldx #>asciiCHR
0EE69 A9 D5                       lda #<asciiCHR
0EE6B 20 93 E3                    jsr vram_unrle
0EE6E                           
0EE6E                             ; start chat
0EE6E 20 09 EA                    jsr startChat
0EE71                           
0EE71                           ; ################################################################################
0EE71                           ; NMI HANDLER
0EE71                           
0EE71                           vector_nmi:
0EE71                             ; save stack
0EE71 48                          pha
0EE72 8A                          txa
0EE73 48                          pha
0EE74 98                          tya
0EE75 48                          pha
0EE76                           
0EE76                             ; if rendering is disabled, do not access the VRAM at all
0EE76 A5 23                       lda PPU_MASK_VAR
0EE78 29 18                       and #%00011000
0EE7A D0 03                       bne doUpdate
0EE7C 4C B6 EE                    jmp skipAll
0EE7F                           
0EE7F                           doUpdate:
0EE7F                           
0EE7F                             ; update OAM
0EE7F A2 00                       ldx #$00
0EE81 8E 03 20                    stx $2003
0EE84 A9 02                       lda #>$0200
0EE86 8D 14 40                    sta $4014
0EE89                           
0EE89                             ; update palette if needed
0EE89 A5 25                       lda <palUpdate
0EE8B F0 0E                       beq updVRAM
0EE8D 30 03                       bmi fadePal
0EE8F 4C 98 EE                    jmp flushPal
0EE92                           fadePal:
0EE92                           
0EE92 20 CA E2                    jsr fadePalette
0EE95 4C 9B EE                    jmp updVRAM
0EE98                           
0EE98                           flushPal:
0EE98                           
0EE98 20 27 E2                    jsr flushPalette
0EE9B                           
0EE9B                           updVRAM:
0EE9B                           
0EE9B A5 31                       lda VRAM_UPDATE
0EE9D F0 09                       beq skipUpd
0EE9F 86 31                       stx VRAM_UPDATE
0EEA1                             
0EEA1 A5 32                       lda NAME_UPD_ENABLE
0EEA3 F0 03                       beq skipUpd
0EEA5                           
0EEA5 20 3E E3                    jsr flush_vram_update_nmi
0EEA8                           
0EEA8                           skipUpd:
0EEA8                           
0EEA8 A9 00                       lda #$00
0EEAA 8D 06 20                    sta $2006
0EEAD 8D 06 20                    sta $2006
0EEB0                           
0EEB0 8D 05 20                    sta $2005
0EEB3 8D 05 20                    sta $2005
0EEB6                           
0EEB6                           skipAll:
0EEB6                           
0EEB6 A5 22                       lda PPU_CTRL_VAR
0EEB8 8D 00 20                    sta $2000
0EEBB                           
0EEBB A5 23                       lda PPU_MASK_VAR
0EEBD 8D 01 20                    sta $2001
0EEC0                           
0EEC0                           skipClassicNMI:
0EEC0                           
0EEC0 E6 20                       inc FRAME_CNT1
0EEC2 E6 21                       inc FRAME_CNT2
0EEC4 A5 21                       lda FRAME_CNT2
0EEC6 C9 06                       cmp #$06
0EEC8 D0 04                       bne skipNtsc
0EECA A9 00                       lda #$00
0EECC 85 21                       sta FRAME_CNT2
0EECE                           
0EECE                           skipNtsc:
0EECE                           
0EECE                             ; restore stack
0EECE 68                          pla
0EECF A8                          tay
0EED0 68                          pla
0EED1 AA                          tax
0EED2 68                          pla
0EED3                           
0EED3                             ; return
0EED3 40                          rti
0EED4                           
0EED4                           
0EED4                           ; ################################################################################
0EED4                           ; IRQ HANDLER
0EED4                           
0EED4                           vector_irq:
0EED4 40                          rti
0EED5                           
0EED5                           
0EED5                           ; ################################################################################
0EED5                           ; DATAS
0EED5                           
0EED5                           asciiCHR:
0EED5 01 00 01 0F 7E FF A5 A5..   .incbin "gfx/ascii.chr.rle"
0F65B                           
0F65B                           ; ################################################################################
0F65B                           ; CREDITS
0F65B                           
0F65B                           credits:
0F65B 2F 52 61 69 6E 62 6F 77..   .db "/Rainbow Chat example v"
0F672                             version:
0F672 30 2E 30 2E 31              .db "0.0.1"
0F677 62                          .db "b"
0F678                             build:
0F678 32 36 31                    .db "261"
0F67B 2F 32 30 32 30 2D 32 30..   .db "/2020-2022 Broke Studio"
0F692 2F 63 6F 64 65 20 41 6E..   .db "/code Antoine Gohin"
0F6A5 2F 74 68 78 20 4C 75 64..   .db "/thx Ludy<3/"
0F6B1                           
0F6B1                           ; ################################################################################
0F6B1                           ; VECTORS
0F6B1                           
0F6B1 00 00 00 00 00 00 00 00..   .org $FFFA
0FFFA                           ;.segment "VECTORS"
0FFFA 71 EE                       .word vector_nmi    ; $FFFA vblank nmi
0FFFC C2 ED                       .word vector_reset  ; $FFFC reset
0FFFE D4 EE                       .word vector_irq    ; $FFFE irq / brk
